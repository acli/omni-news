#!/usr/bin/perl
# vi:set sw=2 ai sm:
#
# Copyright 2021 by Ambrose Li <ambrose.li@gmail.com>
# Pull program schedule from OMNI TV's site to try to figure out when news is aired
# because the time can shift around or news for the day can get cancelled for hockey
#
# Feed for Toronto is here: https://www.omnitv.ca/on/yue-can/schedule/
# Province probably makes a difference, but language doesn't because this is just the master schedule
# The schedule is a mess of spans and b's (not even divs) that's completely unreadable on w3m

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
#use v5.14; # //u modifier
use utf8;
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX ":sys_wait_h";
use Data::Dumper;
use Getopt::Long;

use vars qw( $sysline_mode $genmon_mode );
use vars qw( $debug $test_data_file );
use vars qw( $verbose );
use vars qw( $lang );
use vars qw( $prov );
use vars qw( $now );
use vars qw( $chinese_p );
use vars qw( $next_mode_p );
use vars qw( $speak_mode_p );
use vars qw( $preferred_English_voice );
$lang = 'Cantonese';
$prov = 'on';



sub STATE__INITIAL   () { 'INITIAL' }
sub STATE__CHANNEL   () { 'CHANNEL' }
sub STATE__DAYS      () { 'DAYS' }
sub STATE__DAY       () { 'DAY' }
sub STATE__TIMES     () { 'TIMES' }
sub STATE__SCHEDULE  () { 'SCHEDULE' }
sub STATE__SHOW_NAME () { 'SHOW_NAME' }
sub STATE__LIMINAL   () { 'LIMINAL' }
sub STATE__FOOTER    () { 'FOOTER' }

use vars qw( %langs );
%langs = (
  'Arabic' => '阿拉伯文',
  'Cantonese' => '廣東話',
  'Filipino' => '菲律賓文',
  'Italian' => '意大利文',
  'Mandarin' => '國語',
  'Punjabi' => '旁遮普文',
);

use vars qw( %months %dows );
%months = (
  'Jan' => ['January', '一月'],
  'Feb' => ['February', '二月'],
  'Mar' => ['March', '三月'],
  'Apr' => ['April', '四月'],
  'May' => ['May', '五月'],
  'Jun' => ['June', '六月'],
  'Jul' => ['July', '七月'],
  'Aug' => ['August', '八月'],
  'Sep' => ['September', '九月'],
  'Oct' => ['October', '十月'],
  'Nov' => ['Novermber', '十一月'],
  'Dec' => ['December', '十二月'],
);
%dows = (
  'Mon' => ['Monday', '星期一'],
  'Tue' => ['Tuesday', '星期二'],
  'Wed' => ['Wednesday', '星期三'],
  'Thu' => ['Thursday', '星期四'],
  'Fri' => ['Friday', '星期五'],
  'Sat' => ['Saturday', '星期六'],
  'Sun' => ['Sunday', '星期日'],
);

use vars qw( %chinese_program_name );
%chinese_program_name = (
  'OMNI News: Cantonese Edition' => '粵語新聞',
  'Focus Cantonese' => '都市聚焦',
);

sub format_date ($$$) {
  my($month, $day, $dow) = @_;
  my $fmt = $chinese_p? '%s%s日%s': $speak_mode_p? '%3$s %1$s %2$s': '%3$s, %1$s %2$s';
  return sprintf $fmt, $months{$month}->[$chinese_p], $day, $dows{$dow}->[$chinese_p];
}

sub format_time ($) {
  my($time) = @_;
  my($hour, $minute) = $time =~ /^(\d\d):(\d\d)$/? ($1 + 0, $2 + 0): $time =~ /^(\d+)$/? ($time/60, $time%60): undef;
  my $it;
  if ($chinese_p) {
    my $h = ($hour + 11)%12 + 1;
    my $m = $minute;
    if ($speak_mode_p) {
      $h = '二' if $h == 2;
      if ($m == 2) {
	$m = '零二';
      } elsif ($m && $m < 10) {
	$m = "零$m";
      }
    }
    $it = sprintf('%s%s時', ($hour == 0? '午夜': $hour < 6? '凌晨': $hour < 12? '上午': $hour == 12? '中午': $hour < 20? '下午': '晚上'), $h);
    if ($minute == 30) {
      $it .= '半';
    } elsif ($minute) {
      $it .= sprintf('%s分', $m);
    }
  } else {
    my $fmt1 = $speak_mode_p? '[[nmbr NORM]] %s ': '%s:';
    my $fmt2 = $speak_mode_p? '[[nmbr NORM]] %s ': '%02d ';
    $it = sprintf($fmt1, ($hour + 11)%12 + 1);
    $it .= sprintf($fmt2, $minute) if !$speak_mode_p || $minute;
    $it .= ($hour == 0? 'midnight': $hour < 12? 'a.m.': $hour == 12? 'noon': 'p.m.');
  }
  return $it;
}

sub format_duration ($) {
  my($minutes) = @_;
  my $hours = $minutes/60;
  my $it;
  $minutes %= 60;
  $it .= sprintf(($chinese_p? '%s 小時': '%s %s'), $hours, ($hours == 1? 'hour': 'hours')) if $hours;
  $it .= sprintf(($chinese_p? '%s 分鐘': '%s %s'), $minutes, ($minutes == 1? 'minute': 'minutes')) if $minutes;
  return $it;
}

sub macos_p () {
  return -f '/mach_kernel';
}

sub preferred_English_voice () {
  if (!defined $preferred_English_voice) {
    my %voices;
    my @cmd = ('say', '-v', '?');
    print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug || $verbose;

    my $h = open(INPUT, '-|');
    die "$0: $cmd[0]: fork: $!\n" unless defined $h;
    if ($h) {
      for (;;) {
	my $s = scalar <INPUT>;
      last unless defined $s;
	$voices{$1} = $2 if $s =~ /^(.*?\S)\s+([a-z]{2}[-_](?:[A-Z][A-Z]|[a-z]+))\s+#/s;
      }
      close INPUT;
    } else {
      exec {$cmd[0]} @cmd;
      die "$0: $cmd[0]: exec: $!\n";
    }
    for my $pref (('Fiona', 'Emily', 'Karen', 'Samantha')) {
      $preferred_English_voice = $pref if defined $voices{$pref};
    last if defined $preferred_English_voice;
    }
  }
  return $preferred_English_voice;
}

sub communicate ($) {
  my($s) = @_;
  my @cmd;
  if (!$speak_mode_p) {
    printf "%s\n", $s;
  } elsif (macos_p && $chinese_p) {
    @cmd = ('say', '-v', 'Sin-Ji', $s);
  } elsif (macos_p) {
    @cmd = ('say', '-v', preferred_English_voice, $s);
  } else {
    @cmd = ('espeak', $s);
  }
  if (@cmd) {
    print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug || $verbose;
    system { $cmd[0] } @cmd;
  }
}

sub get_feed_data () {
  my $data_dir = "$ENV{HOME}/.cache/omni-news";
  my $data_file;
  my $basename = "$prov.html";
  if (defined $test_data_file) {
    $data_file = $test_data_file;
    print STDERR "DEBUG: using test data from \"$data_file\"\n" if $debug || $verbose;
  } else {
    if (!-d $data_dir) {
      mkdir $data_dir or warn "$0: $data_dir: $!\n";
    }
    $data_file = "$data_dir/$basename";
    my $use_cached_data = 0;
    if (!-f $data_file) {
      print STDERR "DEBUG: need to get new data because nothing was cached\n" if $debug || $verbose;
    } elsif (time - (stat $data_file)[9] > 7200) {
      print STDERR "DEBUG: need to get new data because cache was stale\n" if $debug || $verbose;
    } else {
      print STDERR "DEBUG: using cached data\n" if $debug || $verbose;
      $use_cached_data = 1;
    }
    if (!$use_cached_data) {
      my @cmd = ('wget', '-q', '-O', $data_file, "https://www.omnitv.ca/$prov/yue-can/schedule/");
      print STDERR 'DEBUG: running: ', join(' ', @cmd), "\n" if $debug || $verbose;
      my $pid = fork;
      die "$0: get_feed_data: $cmd[0]: fork: $!\n" unless defined $pid;
      if (!$pid) {
	exec {$cmd[0]} @cmd;
	die "$0: get_feed_data: $cmd[0]: exec: $!\n";
      }
      wait; # otherwise we'll try to open the file before wget saves it
    }
  }
  open(INPUT, '<:utf8', $data_file) or die "$0: $data_file: $!\n";
  my $it = {};
  my $regs = {};
  my @readahead;
  for (my $state = STATE__INITIAL, my $i = -1, my $node;;) {
    my $s = @readahead? pop @readahead: scalar <INPUT>;
  last unless defined $s;
    chomp $s;
    printf STDERR "DEBUG: state %s input (%s)\n", $state, $s if $debug > 2;
    $s =~ s/\&(?:#xB0|deg);/°/g;
    $s =~ s/\b([Ii])nt'l\b/\1nternational/g;
    my $debug__orig_state = $state;
    if ($state eq STATE__INITIAL || $state eq STATE__LIMINAL) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	$regs->{'current-channel'} = $2;
	$state = STATE__CHANNEL;
	$node = {};
	$i += 1;
      }
    } elsif ($state eq STATE__CHANNEL) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<div class="day-picker-view">\s*$/) {
	$state = STATE__DAYS;
      }
    } elsif ($state eq STATE__DAYS) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<span.*?data-date="day-(\d+)".*?>\s*$/) {
	$regs->{'current-day'} = $1 + 0;
	$state = STATE__DAY;
      }
    } elsif ($state eq STATE__DAY) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<span class="day-name\b.*?">(\w+)<\/span>\s*$/) {
	$regs->{$regs->{'current-day'}}->{'dow'} = $1;
      } elsif ($s =~ /^\s*<span class="date">(\w+) (\d+)<\/span>\s*$/) {
	die sprintf("%s: Expecting day %s but got %s\n", $s, $regs->{'current-day'}, $2) unless $2 == $regs->{'current-day'};
	$it->{$regs->{'current-day'}}->{'month'} = $1;
	$it->{$regs->{'current-day'}}->{'dow'} = $regs->{$regs->{'current-day'}}->{'dow'};
      } elsif ($s =~ /^\s*<span.*?data-date="day-(\d+)".*?>\s*$/) {
	$regs->{'current-day'} = $1 + 0;
      } elsif ($s =~ /^\s*<div class="time-row">\s*$/) {
	delete $regs->{'current-day'};
	$regs->{'times'} = [];
	$state = STATE__TIMES;
      }
    } elsif ($state eq STATE__TIMES) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<span .*?data-timeslot="(\d\d:\d\d)">\s*$/) {
	$regs->{$1} = @{$regs->{'times'}};
	push @{$regs->{'times'}}, $1;
      } elsif ($s =~ /^\s*<div class="schedule-data day(\d+)">\s*$/) {
	$regs->{'current-day'} = $1 + 0;
	$state = STATE__SCHEDULE;
	printf STDERR "DEBUG: %s schedule for day %s\n", $regs->{'current-channel'}, $1 if $debug > 1;
      }
    } elsif ($state eq STATE__SCHEDULE || $state eq STATE__SHOW_NAME) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<div class="schedule-data day(\d+)">\s*$/) {
	push @readahead, $s;
	$state = STATE__TIMES;
      } elsif ($s =~ /<span class=".*?duration(\d+).*?" data-timeslot="(\d\d:\d\d)">/) {
	$regs->{'current-time'} = $2;
	$node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'duration'} = $1 + 0;
      } elsif ($s =~ /<span class="show-name">(.+)/) {
	$state = STATE__SHOW_NAME;
	push @readahead, $1;
      } elsif ($s =~ /<!--\s*schedule-view\s*-end\s*-->\s*$/) {
	$it->{$regs->{'current-channel'}} = $node;
	$state = STATE__LIMINAL;
      } elsif ($s =~ /^\s*<footer.*?>\s*$/) {
	push @{$it->{'data'}}, $node;
	$state = STATE__FOOTER;
      } elsif ($s =~ /^\s*<span class="(?:ratings|more)">\s*$/) { # this should happen only if state eq STATE__SHOW_NAME
	$state = STATE__SCHEDULE;
      } elsif ($state eq STATE__SHOW_NAME) {
	$s =~ s/<[^<>]*>//sg;
	$s =~ s/^\s+//sg;
	$s =~ s/\s+$//sg;
	if ($s =~ /\S/s) {
	  $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'} .= ' ' if defined $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'};
	  $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'} .= $s;
	}
      }
    } else {
      die "$0: Internal error: Reached unknown state \"$state\"\n";
    }
    print STDERR "DEBUG: switched state from $debug__orig_state to $state\n" if $debug && $debug__orig_state ne $state;
  last if $state eq STATE__FOOTER;
  }
  print STDERR "DEBUG: end of feed reached\n" if $debug;
  close INPUT;
  return $it;
}

sub find_language_program ($$) {
  my($data, $t) = @_;
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
  my $target_day = $mday;
  my $target_month = POSIX::strftime('%b', $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
  my $target_dow = uc POSIX::strftime('%a', $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
  my @found;
  print STDERR "DEBUG: target day $target_day, month $target_month, dow $target_dow\n" if $debug;
  for my $channel (keys %$data) {
    my $channel_data = $data->{$channel};
    if (ref $channel_data) {
      for my $day (keys %$channel_data) {
	my $day_data = $channel_data->{$day};
	if ($day == $target_day && ref $day_data) {
	  for my $time (keys %$day_data) {
	    my $time_data = $day_data->{$time};
	    if (ref $time_data && (!defined $lang || $time_data->{'name'} =~ /$lang/)) {
	      push @found, [$time, uc $channel, ucfirst lc $data->{$day}->{'dow'}, $day, $data->{$day}->{'month'}, $time_data->{'name'}, $time_data->{'duration'}];
	    }
	  }
	}
      }
    }
  }
  return [sort { $a->[0] cmp $b->[0] } @found];
}

sub display_listing ($$) {
  my($data, $t) = @_;
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
  my $target_time = 60*$hour + $min if $next_mode_p;
  my $something_done_p;
  my $all_same_channel_p;
  my @data_to_display;
  for my $node (@$data) {
    my($time, $channel, $dow, $day, $month, $name, $duration) = @$node;
    my $broadcast_time = 60*$1 + $2 if $time =~ /^(\d\d):(\d\d)$/;
    my $flag;
    if (!defined $target_time) {
      $flag = 1;
    } elsif ($broadcast_time > $target_time) {
      $flag = 2;
    } elsif ($broadcast_time < $target_time && ($broadcast_time + $duration) > $target_time) {
      $flag = 3;
    }
    if (defined $flag) {
      push @data_to_display, [$flag, $broadcast_time, $broadcast_time + $duration, $time, $channel, $dow, $day, $month, $name, $duration];
      if (!defined $all_same_channel_p) {
	$all_same_channel_p = $channel;
      } elsif ($all_same_channel_p && $all_same_channel_p ne $channel) {
	$all_same_channel_p = 0;
      }
      $something_done_p = 1;
    }
  last if $something_done_p && defined $target_time;
  }
  $something_done_p = 0;
  for my $node (@data_to_display) {
    my($flag, $start_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration) = @$node;
    my $lead;
    my $comment;
    if ($flag == 1) {
      if ($chinese_p) {
	my $tmp = format_time($end_time);
	$tmp =~ s/午夜|凌晨|上午|中午|下午|晚上//;
	if (!$something_done_p) {
	  $lead .= format_date($month, $day, $dow);
	  $lead .= "，喺 $channel 嘅節目：" if $all_same_channel_p;
	}
	$lead .= sprintf('%s至%s', format_time($time), $tmp);
	$lead .= "喺 $channel 播放" unless $all_same_channel_p;
	$lead .= '：'
      } else {
	if (!$something_done_p) {
	  $lead .= sprintf('Schedule for %s', format_date($month, $day, $dow));
	  $lead .= sprintf(' on %s', $channel) if $all_same_channel_p;
	  $lead .= ":\n";
	}
	$lead .= format_time($time);
	$lead .= " on $channel" unless $all_same_channel_p;
	$lead .= ': ';
	$comment = sprintf(' (%s)', format_duration $duration);
      }
    } elsif ($flag == 2) {
      if ($chinese_p) {
	$lead .= "$channel " unless $all_same_channel_p;
	$lead .= sprintf('下一個節目係，%s播放，%s嘅，', format_time($time), format_duration($duration));
      } else {
	$lead .= sprintf('Next at %s', format_time $time);
	$lead .= " on $channel" unless $all_same_channel_p;
	$lead .= ': ';
      }
    } elsif ($flag == 3) {
      if ($chinese_p) {
	$lead .= "$channel " unless $all_same_channel_p;
	$lead .= '現正播放嘅節目係：';
	$comment = sprintf('，直至%s', format_time($end_time));
      } else {
	$lead = 'Currently on ';
	$lead .= "$channel " unless $all_same_channel_p;
	$lead .= sprintf('until %s: ', format_time($end_time));
      }
    }
    $name = $chinese_program_name{$name} if $chinese_p && defined $chinese_program_name{$name};
    communicate $lead . $name . $comment;
    $something_done_p = 1;
  }
}

sub usage (;$) {
  my($st) = @_;
  my $h = $st? *STDERR: *STDOUT;
  print $h <<EOF;
Usage: $0 [OPTION]...
Figure out when OMNI News Cantonese is being aired by checking the scheduile.

  -a, --all                   Match all programs instead of a specific language
  -I, --data-file=FILE        Use test feed data in specified FILE
  -g, --genmon                Terse format suitable as two-line genmon input
  -n, --next                  Display next match instead of all matches
      --province=CODE         Use the province identified by the specified CODE
      --speak                 Speak the result instead of displaying it
  -w, --sysline               Terse format suitable as a sysline .who file
  -W, --what-if=TIMESTAMP     Pretend current time is TIMESTAMP (Unix epoch)
  -v, --verbose               Explain what is being done
  -z, --chinese               Display results in Chinese
      --debug                 Produce lots of debugging output

The codes bc and on are known to exist, but it's not known if they air different
programs in different provinces.
EOF
  exit $st;
}

Getopt::Long::config('bundling');
GetOptions(
  'a|all' => sub { $lang = undef },
  'd|debug' => sub { $debug += 1 },
  'province=s' => \$prov,
  'I|data-file=s' => \$test_data_file,
  'g|genmon' => \$genmon_mode,
  'n|next' => \$next_mode_p,
  'speak' => \$speak_mode_p,
  'w|sysline' => \$sysline_mode,
  'W|what-if=i' => \$now,
  'v|verbose' => \$verbose,
  'z|zh|chinese' => \$chinese_p,
  'help' => \&usage,
) || usage(1);

die "$0: \"$prov\" does not look like a valid city code\n" unless $prov =~ /^[a-z]{2}$/;
$now = time unless defined $now;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

my $data = get_feed_data;
print STDERR 'DEBUG: parsed data is ' . Dumper $data if $debug;

my $listing = find_language_program $data, $now;
display_listing $listing, $now;

