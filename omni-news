#!/usr/bin/perl
# vi:set sw=2 ai sm:
#
# Copyright 2021 by Ambrose Li <ambrose.li@gmail.com>
# Pull program schedule from OMNI TV's site to try to figure out when news is aired
# because the time can shift around or news for the day can get cancelled for hockey
#
# Feed for Toronto is here: https://www.omnitv.ca/on/yue-can/schedule/
# Province probably makes a difference, but language doesn't because this is just the master schedule
# The schedule is a mess of spans and b's (not even divs) that's completely unreadable on w3m

# References (for say(1)):
# https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/FineTuning/FineTuning.html
# https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/Phonemes/Phonemes.html

# To investigate:
# https://www.mattmontag.com/personal/mac-os-x-speech-synthesis-markup
# https://developer.apple.com/documentation/applicationservices/1552235-texttophonemes [API reference, requires Javascript]
# https://developer.apple.com/documentation/appkit/nsspeechphonemeinfoexample?language=objc
# https://developer.apple.com/audio/
# https://developer.apple.com/documentation/avfaudio/avaudiosession/capturing_stereo_audio_from_built-in_microphones
# https://stackoverflow.com/questions/37529/simple-audio-input-api-on-a-mac
# -> http://www.portaudio.com/
# -> https://github.com/PortAudio/portaudio

# Historical knowledge only:
# https://github.com/zonque/PulseAudioOSX

# Future use only:
# https://www.musicradar.com/news/someone-finally-came-up-with-a-soundflower-replacement-and-its-free-for-mac-users
# -> https://github.com/ExistentialAudio/BlackHole/releases

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
#use v5.14; # //u modifier
use utf8;
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;

use POSIX ":sys_wait_h";
use Data::Dumper;
use Getopt::Long;

use vars qw( $sysline_mode $genmon_mode );
use vars qw( $debug $test_data_file );
use vars qw( $verbose );
use vars qw( $lang );
use vars qw( $prov );
use vars qw( $now );
use vars qw( $delta_t );
use vars qw( $chinese_p );
use vars qw( $loop_mode_p );
use vars qw( $once_p );
use vars qw( $dry_run_p );
use vars qw( $query_next_program_p );
use vars qw( $query_main_program_p );
use vars qw( $speak_mode_p );
use vars qw( $broadcast_mode_p );
use vars qw( $quiet_p );
use vars qw( $buffered_speech_p $buffered_speech );
use vars qw( $preferred_English_voice );
$lang = 'Cantonese';
$prov = 'on';

use vars qw( $data_dir $temp_file $esd_server $pa_server $pa_sink );
$data_dir = "$ENV{HOME}/.cache/omni-news";
$temp_file = "$data_dir/temp.wav";
#$esd_server = 'pingviini';
($pa_server, $pa_sink) = ('osmc', 'rtp');

use vars qw( $max_staleness );
$max_staleness = 3*86400; # 3 days - the published schedule spans 2 weeks so in theory this number can be even bigger but just in case

sub STATE__INITIAL   () { 'INITIAL' }
sub STATE__CHANNEL   () { 'CHANNEL' }
sub STATE__DAYS      () { 'DAYS' }
sub STATE__DAY       () { 'DAY' }
sub STATE__TIMES     () { 'TIMES' }
sub STATE__SCHEDULE  () { 'SCHEDULE' }
sub STATE__SHOW_NAME () { 'SHOW_NAME' }
sub STATE__LIMINAL   () { 'LIMINAL' }
sub STATE__FOOTER    () { 'FOOTER' }

use vars qw( %langs );
%langs = (
  'Arabic' => '阿拉伯文',
  'Cantonese' => '廣東話',
  'Filipino' => '菲律賓文',
  'Italian' => '意大利文',
  'Mandarin' => '國語',
  'Punjabi' => '旁遮普文',
);

use vars qw( %months %dows );
%months = (
  'Jan' => ['January', '一月'],
  'Feb' => ['February', '二月'],
  'Mar' => ['March', '三月'],
  'Apr' => ['April', '四月'],
  'May' => ['May', '五月'],
  'Jun' => ['June', '六月'],
  'Jul' => ['July', '七月'],
  'Aug' => ['August', '八月'],
  'Sep' => ['September', '九月'],
  'Oct' => ['October', '十月'],
  'Nov' => ['Novermber', '十一月'],
  'Dec' => ['December', '十二月'],
);
%dows = (
  'Mon' => ['Monday', '星期一'],
  'Tue' => ['Tuesday', '星期二'],
  'Wed' => ['Wednesday', '星期三'],
  'Thu' => ['Thursday', '星期四'],
  'Fri' => ['Friday', '星期五'],
  'Sat' => ['Saturday', '星期六'],
  'Sun' => ['Sunday', '星期日'],
);

use vars qw( %words );
%words = (
  0 => 'zero',
  1 => 'one',
  2 => 'two',
  3 => 'three',
  4 => 'four',
  5 => 'five',
  6 => 'six',
  7 => 'seven',
  8 => 'eight',
  9 => 'nine',
  10 => 'ten',
  11 => 'eleven',
  12 => 'twelve',
  13 => 'thirteen',
  14 => 'fourteen',
  15 => 'fifteen',
  16 => 'sixteen',
  17 => 'seventeen',
  18 => 'eighteen',
  19 => 'nineteen',
  20 => 'twenty',
  30 => 'thirty',
  40 => 'forty',
  50 => 'fifty',
);

use vars qw( %channel_pronunciations );
%channel_pronunciations = (
  # XXX This is hopeless. The Sin Ji voice cannot pronounce English, but there is no support for English phonemes
  'omni1' => ['Omni One', 'Omni One'],
  'omni2' => ['Omni Two', 'Omni Two'],
);

# FIXME In theory we can poll https://www.omnitv.ca/on/en/shows/ but the page is pure JS that doesn't even work on Brave (even with shields down)
use vars qw( %chinese_program_name );
%chinese_program_name = (
  'OMNI News: Cantonese Edition' => '粵語新聞',
  'Focus Cantonese' => '都市聚焦',
  'Showers of Blessings' => '恩雨之聲',
  'Close to Culture' => '拉近文化', # ??? WTF is this??? [apparently an iCable production]
);

use vars qw( $lat $lon );
use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

sub log_something ($$) {
  my($msg, $flag) = @_;
  chomp $msg;
  for my $s (split(/\n/, $msg)) {
    printf STDERR "%d%s\t%s\n", time, $flag, $s;
  }
}

sub log_debug ($) {
  return log_something $_[0], '#';
}

sub log_input ($) {
  return log_something $_[0], '<';
}

sub log_output ($) {
  return log_something $_[0], '>';
}

sub show_cmd (\@;$) {
  my($cmd, $dry_run_p) = @_;
  log_debug sprintf '%s: %s', (defined $dry_run_p && $dry_run_p? 'pretending to run': 'running'), join(' ', map { /'/? (/"/? eval {
	s/"/\\"/;
	"\"$_\"";
      }: "\"$_\""): /\s/? "'$_'": $_ } @$cmd) if $debug || $verbose;
}

sub RUN_CMD__IGNORE_ERRORS  () { 1 }
sub RUN_CMD__IGNORE_SIGNALS () { 2 }

sub run_cmd_real (\@;$) {
  my($cmd, $opt) = @_;
  show_cmd @$cmd;
  my $st = system { $cmd->[0] } @$cmd;

  # Try to be reasonable when it comes to allowing ^C to do its thing but ignoring errors
  my($msg, $fatal_p);
  if ($st & 127) {
    $msg = sprintf('Command %s killed by signal %d', $cmd->[0], $st & 127);
    $fatal_p = defined $opt && ($opt & RUN_CMD__IGNORE_SIGNALS);
  } elsif ($st) {
    $msg = sprintf('Command %s returned exit status %d', $cmd->[0], $st >> 8);
    $fatal_p = defined $opt && ($opt & RUN_CMD__IGNORE_ERRORS);
  }
  if (defined $msg) {
    die "Unexpected error: $msg\n" if defined $fatal_p && $fatal_p;
    log_debug $msg;
  }
  return $st;
}

sub run_cmd (\@;$) {
  my($cmd, $opt) = @_;
  if ($dry_run_p) {
    show_cmd @$cmd, $dry_run_p;
  } else {
    run_cmd_real @$cmd, $opt;
  }
}

sub turn_tv_on () {
  my @cmd = ('ssh', '-T', '-l', 'tv-on', 'osmc');
  return run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
}

sub turn_tv_off () {
  my @cmd = ('ssh', '-T', '-l', 'tv-off', 'osmc');
  return run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  log_debug "guessed city=($city)" if $debug;
  my @cmd = qw(hebcal cities);
  show_cmd @cmd if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = quotemeta $city;
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp;
      if ($s =~ /^$re \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' [EW] long/) {
        no integer;
        $it = {
              'lat' => ($1 + $2/60)*($3 eq 'N'? 1: -1),
              'lon' => ($4 + $5/60)*($6 eq 'E'? 1: -1),
            };
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

sub adjusted_time () {
  my $t = time;
  $t += $delta_t if defined $delta_t;
  return $t;
}

sub in_words ($) {
  my($n) = @_;
  my $it;
  if (defined $words{$n}) {
    $it = $words{$n};
  } elsif (defined $words{+my $det = 10*int($n/10)}) {
    $it = sprintf('%s-%s', $words{$det}, $words{+$n%10});
  }
  die "Can't put \"$n\" in words" unless defined $it;
  return $it;
}

sub format_date ($$$) {
  my($month, $day, $dow) = @_;
  my $fmt = $chinese_p? '%s%s日%s': $speak_mode_p? '%3$s %1$s %2$s': '%3$s, %1$s %2$s';
  return sprintf $fmt, $months{$month}->[$chinese_p], $day, $dows{$dow}->[$chinese_p];
}

sub format_time ($) {
  my($time) = @_;
  my($hour, $minute) = $time =~ /^(\d\d):(\d\d)$/? ($1 + 0, $2 + 0): $time =~ /^(\d+)$/? ($time/60, $time%60): undef;
  ($_, $_, $_, my $mday, my $mon, my $year) = localtime $now;
  my $midnight_today = POSIX::mktime(0, 0, 0, $mday, $mon, $year);
  my $t = POSIX::mktime(0, $minute, $hour, $mday, $mon, $year);
  my $sunrise = estimate_sunrise $now;
  my $sunset = estimate_sunset $now;
  my $before_sunrise_p = $t < $sunrise;
  my $after_sunset_p = $t >= $sunset;
  my $it;
  if ($chinese_p) {
    my $h = ($hour + 11)%12 + 1;
    my $m = $minute;
    if ($speak_mode_p) {
      $h = ($speak_mode_p? '兩': '二') if $h == 2;
      if ($m == 2) {
	$m = '零二';
      } elsif ($m && $m < 10) {
	$m = "零$m";
      }
    }
    my $fmt = $speak_mode_p? '%s%s點': '%s%s時';
    $it = sprintf($fmt, ($hour == 0 && $minute == 0? '午夜': $hour == 12 && $minute == 0? '中午': $before_sunrise_p? '凌晨': $after_sunset_p? '晚上': $hour < 12? '上午': '下午'), $h);
    if ($minute == 30) {
      $it .= '半';
    } elsif ($minute) {
      $it .= sprintf('%s分', $m);
    }
  } else {
    my($fmt1, $fmt2) = $speak_mode_p? (sub { in_words($_[0]) }, sub { in_words($_[0]) }): ('%2d:', '%02d');
    my($am, $pm, $noon, $midnight) = $speak_mode_p? ('a.m.', 'p.m.', 'noon', 'midnight'): ('am', 'pm', 'pm', 'am');
    my $display_hour = ($hour + 11)%12 + 1;
    $it = ref $fmt1? &$fmt1($display_hour) . ' ': sprintf($fmt1, $display_hour);
    $it .= ref $fmt2? &$fmt2($minute) . ' ': sprintf($fmt2, $minute) if !$speak_mode_p || $minute;
    $it .= ($hour == 0? $midnight: $hour < 12? $am: $hour == 12? $noon: $pm);
  }
  return $it;
}

sub format_duration ($) {
  my($minutes) = @_;
  my $it;
  if ($minutes) { # the schedule is so inaccurate that some programs are marked as duration0
    my $hours = $minutes/60;
    $minutes %= 60;
    $it .= sprintf(($chinese_p? '%s 小時': '%s %s'), $hours, ($hours == 1? 'hour': 'hours')) if $hours;
    $it .= sprintf(($chinese_p? '%s 分鐘': '%s %s'), $minutes, ($minutes == 1? 'minute': 'minutes')) if $minutes;
  }
  return $it;
}

sub format_channel ($) {
  my($channel) = @_;
  return $speak_mode_p && defined $channel_pronunciations{$channel}->[$chinese_p]? $channel_pronunciations{$channel}->[$chinese_p]: uc $channel;
}

sub format_language ($) {
  my($lang) = @_;
  return $chinese_p && defined $lang && $langs{$lang}? $langs{$lang}: $lang;
}

sub calculate_real_time ($;$) {
  my($delta_min, $origin) = @_;

  # In theory we can just return $origin + 60*$delta_min, in practice this is wrong because DST is a thing
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(defined $origin? $origin: $now);
  if (!defined $origin) {
    $origin = POSIX::mktime(0, 0, 0, $mday, $mon, $year) unless defined $origin;
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $origin;
  }
  return POSIX::mktime(0, $delta_min%60, $delta_min/60, $mday, $mon, $year);
}

sub macos_p () {
  return -f '/mach_kernel';
}

sub preferred_English_voice () {
  if (!defined $preferred_English_voice) {
    my %voices;
    my @cmd = ('say', '-v', '?');
    show_cmd @cmd;

    my $h = open(INPUT, '-|');
    die "$0: $cmd[0]: fork: $!\n" unless defined $h;
    if ($h) {
      for (;;) {
	my $s = scalar <INPUT>;
      last unless defined $s;
	$voices{$1} = $2 if $s =~ /^(.*?\S)\s+([a-z]{2}[-_](?:[A-Z][A-Z]|[a-z]+))\s+#/s;
      }
      close INPUT;
    } else {
      exec {$cmd[0]} @cmd;
      die "$0: $cmd[0]: exec: $!\n";
    }
    for my $pref (('Fiona', 'Emily', 'Karen', 'Samantha')) {
      $preferred_English_voice = $pref if defined $voices{$pref};
    last if defined $preferred_English_voice;
    }
  }
  return $preferred_English_voice;
}

sub start_talking () {
  $buffered_speech_p = 1;
}

sub communicate ($) {
  my($s) = @_;
  my @cmd;
  # DVD quality = 48k = 49152, CD = 44.1k = 50×294×3  = 44100, tape = 32k = 32768, AM radio = 22.05k (= 22050?), phone = 8k = 8192
  # Passing most of these to --bit-rate doesn't actually work; in particular, setting it to 8k will appear to work but produce silence.
  # Default rate seems to be 22050, but explicitly setting it to 22050 will give "Setting bit rate failed: prop"; I hate Apple.
  my @opts = ('--file-format', 'WAVE', '--data-format', 'ulaw', '-o', $temp_file) if $broadcast_mode_p;
  my $pause = '[[slnc 1000]]' if macos_p;
  if (!$speak_mode_p) {
    log_output $s if $debug;
    printf "%s\n", $s;
  } elsif ($buffered_speech_p) {
    $buffered_speech .= '。' if $chinese_p && defined $buffered_speech && $buffered_speech !~ /(?:，|。|！|？)$/s;
    $buffered_speech .= $s =~ /^[a-z]/? ';': '.' if !$chinese_p && defined $buffered_speech && $buffered_speech !~ /[\.,:;!\?]$/s;
    $buffered_speech .= ' ' if !$chinese_p && defined $buffered_speech && $buffered_speech !~ /\s$/s;
    $buffered_speech .= $s;
  } elsif (macos_p && $chinese_p) {
    @cmd = ('say', @opts, '-v', 'Sin-Ji', $s, $pause);
  } elsif (macos_p) {
    @cmd = ('say', @opts, '-v', preferred_English_voice, $s, $pause);
  } else {
    @cmd = ('espeak', $s);
  }
  if (@cmd) {
    run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
    if ($broadcast_mode_p) {
      if (defined $pa_server) {
	@cmd = ('paplay', '-s', $pa_server, (defined $pa_sink? ('-d', $pa_sink): ()), $temp_file);
      } else {
	@cmd = ('esdplay', '-s', $esd_server, $temp_file);
      }
      run_cmd @cmd;
    }
  }
}

sub stop_talking () {
  if ($buffered_speech_p) {
    $buffered_speech_p = 0;
    communicate $buffered_speech;
  }
  $buffered_speech = undef;
}

sub feed_url () {
  return "https://www.omnitv.ca/$prov/yue-can/schedule/";
}

sub get_feed_data () {
  my $data_file;
  my $basename = "$prov.html";
  if (defined $test_data_file) {
    $data_file = $test_data_file;
    log_debug "using test data from \"$data_file\"" if $debug || $verbose;
  } else {
    if (!-d $data_dir) {
      mkdir $data_dir or warn "$0: $data_dir: $!\n";
    }
    $data_file = "$data_dir/$basename";
    my $use_cached_data = 0;
    if (!-f $data_file) {
      log_debug 'need to get new data because nothing was cached' if $debug || $verbose;
    } elsif (time - (stat $data_file)[9] > $max_staleness) {
      log_debug 'need to get new data because cache was stale' if $debug || $verbose;
    } elsif ((stat $data_file)[7] == 0) {
      log_debug 'need to get new data because cache file was empty' if $debug || $verbose;
    } else {
      log_debug 'using cached data' if $debug;
      $use_cached_data = 1;
    }
    if (!$use_cached_data) {
      my @cmd = ('wget', '-q', '-O', $data_file, feed_url);
      show_cmd @cmd;
      my $pid = fork;
      die "$0: get_feed_data: $cmd[0]: fork: $!\n" unless defined $pid;
      if (!$pid) {
	exec {$cmd[0]} @cmd;
	die "$0: get_feed_data: $cmd[0]: exec: $!\n";
      }
      wait; # otherwise we'll try to open the file before wget saves it
    }
  }
  open(INPUT, '<:utf8', $data_file) or die "$0: $data_file: $!\n";
  my $it = {};
  my $regs = {};
  my @readahead;
  for (my $state = STATE__INITIAL, my $i = -1, my $node;;) {
    my $s = @readahead? pop @readahead: scalar <INPUT>;
  last unless defined $s;
    chomp $s;
    log_debug "state $state" if $debug > 2;
    log_input $s if $debug > 2;
    $s =~ s/\&(?:#xB0|deg);/°/g;
    $s =~ s/\b([Ii])nt'l\b/\1nternational/g;
    my $debug__orig_state = $state;
    if ($state eq STATE__INITIAL || $state eq STATE__LIMINAL) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	$regs->{'current-channel'} = $2;
	$state = STATE__CHANNEL;
	$node = {};
	$i += 1;
      }
    } elsif ($state eq STATE__CHANNEL) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<div class="day-picker-view">\s*$/) {
	$state = STATE__DAYS;
      }
    } elsif ($state eq STATE__DAYS) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<span.*?data-date="day-(\d+)".*?>\s*$/) {
	$regs->{'current-day'} = $1 + 0;
	$state = STATE__DAY;
      }
    } elsif ($state eq STATE__DAY) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<span class="day-name\b.*?">(\w+)<\/span>\s*$/) {
	$regs->{$regs->{'current-day'}}->{'dow'} = $1;
      } elsif ($s =~ /^\s*<span class="date">(\w+) (\d+)<\/span>\s*$/) {
	die sprintf("%s: Expecting day %s but got %s\n", $s, $regs->{'current-day'}, $2) unless $2 == $regs->{'current-day'};
	$it->{$regs->{'current-day'}}->{'month'} = $1;
	$it->{$regs->{'current-day'}}->{'dow'} = $regs->{$regs->{'current-day'}}->{'dow'};
      } elsif ($s =~ /^\s*<span.*?data-date="day-(\d+)".*?>\s*$/) {
	$regs->{'current-day'} = $1 + 0;
      } elsif ($s =~ /^\s*<div class="time-row">\s*$/) {
	delete $regs->{'current-day'};
	$regs->{'times'} = [];
	$state = STATE__TIMES;
      }
    } elsif ($state eq STATE__TIMES) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<span .*?data-timeslot="(\d\d:\d\d)">\s*$/) {
	$regs->{$1} = @{$regs->{'times'}};
	push @{$regs->{'times'}}, $1;
      } elsif ($s =~ /^\s*<div class="schedule-data day(\d+)">\s*$/) {
	$regs->{'current-day'} = $1 + 0;
	$state = STATE__SCHEDULE;
	log_debug sprintf '%s schedule for day %s', $regs->{'current-channel'}, $1 if $debug > 1;
      }
    } elsif ($state eq STATE__SCHEDULE || $state eq STATE__SHOW_NAME) {
      if ($s =~ /^\s*<div.*data-(channel)="(.*?)">\s*$/) {
	die "STATE__$state encountered unexpected data-channel div, this is a bug.\n";
      } elsif ($s =~ /^\s*<div class="schedule-data day(\d+)">\s*$/) {
	push @readahead, $s;
	$state = STATE__TIMES;
      } elsif ($s =~ /<span class=".*?duration(\d+).*?" data-timeslot="(\d\d:\d\d)">/) {
	$regs->{'current-time'} = $2;
	$node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'duration'} = $1 + 0;
      } elsif ($s =~ /<span class="show-name">(.+)/) {
	$state = STATE__SHOW_NAME;
	push @readahead, $1;
      } elsif ($s =~ /<!--\s*schedule-view\s*-end\s*-->\s*$/) {
	$it->{$regs->{'current-channel'}} = $node;
	$state = STATE__LIMINAL;
      } elsif ($s =~ /^\s*<footer.*?>\s*$/) {
	push @{$it->{'data'}}, $node;
	$state = STATE__FOOTER;
      } elsif ($s =~ /^\s*<span class="(?:ratings|more)">\s*$/) { # this should happen only if state eq STATE__SHOW_NAME
	$state = STATE__SCHEDULE;
      } elsif ($s =~ /^\s*<span class="on-now">\s*(.*?)\s+\((\w+)\)\s+(\d+):(\d\d)\s*-\s*(\d+):(\d\d)\s*([AP]M)\s+(\S+?)<\/span>\s*$/) {
	my($chk_name, $chk_rating, $chk_start_h, $chk_start_m, $chk_end_h, $chk_end_m, $chk_moity, $chk_tz) = ($1, $2, $3, $4, $5, $6, $8, $8);
	my $expected_name = $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'};
	if ($chk_name eq $expected_name) {
	  $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'rating'} = $chk_rating;
	  if ($node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'duration'} == 0) {
	    my $corrected_duration = (60*$chk_end_h + $chk_end_m) - (60*$chk_start_h + $chk_start_m);
	    $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'duration'} = $corrected_duration;
	    log_debug sprintf 'on-now record suggests correct duration for %s is %d', $chk_name, $corrected_duration if $debug;
	  }
	} else {
	  log_debug sprintf 'discarding on-now: expecting %s but found %s', $expected_name, $chk_name if $debug || $verbose;
	}
      } elsif ($state eq STATE__SHOW_NAME) {
	$node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'url'} = $1 if $s =~ /<a\b.*?href="([^""]+)"/;
	$s =~ s/<[^<>]*>//sg;
	$s =~ s/^\s+//sg;
	$s =~ s/\s+$//sg;
	if ($s =~ /\S/s) {
	  $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'} .= ' ' if defined $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'};
	  $node->{$regs->{'current-day'}}->{$regs->{'current-time'}}->{'name'} .= $s;
	}
      }
    } else {
      die "$0: Internal error: Reached unknown state \"$state\"\n";
    }
    log_debug "switched state from $debug__orig_state to $state" if $debug > 1 && $debug__orig_state ne $state;
  last if $state eq STATE__FOOTER;
  }
  log_debug 'end of feed reached' if $debug;
  close INPUT;
  return $it;
}

sub news_program_p ($) {
  my($name) = @_;
  return $name =~ /\bNews\b/;
}

sub match_program_language ($$) {
  my($name, $language) = @_;
  my $it = defined $language && $language =~ /\S/ && $name =~ /$language/;
  $it = 1 if $language eq 'Cantonese' && defined $chinese_program_name{$name};
  return $it;
}

sub find_language_program ($$) {
  my($data, $t) = @_;
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
  my $target_day = $mday;
  my $target_month = POSIX::strftime('%b', $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
  my $target_dow = uc POSIX::strftime('%a', $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
  my @found;
  log_debug "target day $target_day, month $target_month, dow $target_dow" if $debug;
  for my $channel (keys %$data) {
    my $channel_data = $data->{$channel};
    if (ref $channel_data) {
      for my $day (keys %$channel_data) {
	my $day_data = $channel_data->{$day};
	if ($day == $target_day && ref $day_data) {
	  for my $time (keys %$day_data) {
	    my $time_data = $day_data->{$time};
	    if (ref $time_data && (!defined $lang || match_program_language($time_data->{'name'}, $lang))) {
	      push @found, [$time, $channel, ucfirst lc $data->{$day}->{'dow'}, $day, $data->{$day}->{'month'}, $time_data->{'name'}, $time_data->{'duration'}];
	    }
	  }
	}
      }
    }
  }
  return [sort { $a->[0] cmp $b->[0] } @found];
}

sub QUERY__NEXT () { 'NEXT' }
sub QUERY__MAIN () { 'MAIN' }

sub RESULT__MAIN_SEGMENT        () { 'main' }
sub RESULT__LAST_NEWS_BROADCAST () { 'news' }
sub RESULT__LAST_VALID_PROGRAM  () { 'last' }

sub FLAG__TODAYS_SCHEDULE       () { 1 }
sub FLAG__UPCOMING_PROGRAM      () { 2 }
sub FLAG__CURRENT_PROGRAM       () { 3 }

sub filter_listing ($$;$) {
  my($data, $t, $query_type) = @_;
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
  my $target_time = 60*$hour + $min if $query_next_program_p;
  my $something_done_p;
  my $all_same_channel_p;
  my $last_end_time;
  my @data_to_display;
  my @consecutive;
  my $consecutive_has_news_p;
  my @last_news_program;
  my @last_valid_program;
  my $has_news_p;

  $query_type = $query_next_program_p? QUERY__NEXT: $query_main_program_p? QUERY__MAIN: undef if !defined $query_type;
  my $query_main_program_p = $query_type eq QUERY__MAIN;
  my $query_next_program_p = $query_main_program_p || $query_type eq QUERY__NEXT;

  for my $node (@$data) {
    my($time, $channel, $dow, $day, $month, $name, $duration) = @$node;
    my $broadcast_time = 60*$1 + $2 if $time =~ /^(\d\d):(\d\d)$/;
    my $end_time = $broadcast_time + $duration;
    my $flag;
    if (!defined $target_time) {
      $flag = FLAG__TODAYS_SCHEDULE;
    } elsif ($broadcast_time > $target_time) {
      $flag = FLAG__UPCOMING_PROGRAM;
    } elsif ($broadcast_time <= $target_time && $target_time <= $end_time) {
      $flag = FLAG__CURRENT_PROGRAM;
    }
    if (defined $flag) {
      push @data_to_display, [$flag, $broadcast_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration];
      if (!defined $all_same_channel_p) {
	$all_same_channel_p = $channel;
      } elsif ($all_same_channel_p && $all_same_channel_p ne $channel) {
	$all_same_channel_p = 0;
      }
      if (defined $last_end_time && $broadcast_time == $last_end_time) {
	push @consecutive, $data_to_display[$#data_to_display];
      } else {
	@consecutive = ($data_to_display[$#data_to_display]);
      }
      @last_news_program = ($data_to_display[$#data_to_display]) if news_program_p $name;
      $something_done_p = 1;
      $last_end_time = $end_time;
      $consecutive_has_news_p = 1 if news_program_p $name;
    } else {
      @last_valid_program = @data_to_display;
      @consecutive = ();
      $consecutive_has_news_p = 0;
    }
  last if $query_main_program_p? @consecutive == 2: $something_done_p && defined $target_time;
  }
  my $it = { 'all-same-channel-p' => $all_same_channel_p, 'results' => \@data_to_display };
  if ($query_main_program_p) {
    if (@consecutive > 1 && $consecutive_has_news_p) {
      $it->{'type'} = RESULT__MAIN_SEGMENT;
      $it->{'results'} = \@consecutive;
    } elsif (@last_news_program) {
      $it->{'type'} = RESULT__LAST_NEWS_BROADCAST;
      $it->{'results'} = \@last_news_program;
    } elsif (@last_valid_program) {
      $it->{'type'} = RESULT__LAST_VALID_PROGRAM;
      $it->{'results'} = \@last_valid_program;
    }
  }
  return $it;
}

sub display_listing ($$) {
  my($filtered_data, $t) = @_;
  my $type = $filtered_data->{'type'};
  my $data = $filtered_data->{'results'};
  my $all_same_channel_p = $filtered_data->{'all-same-channel-p'};

  my %annotated;
  my $something_done_p = 0;
  for my $node (@$data) {
    my($flag, $start_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration) = @$node;
    my $lead;
    my $comment;
    if ($flag == FLAG__TODAYS_SCHEDULE) {
      if ($chinese_p) {
	my $tmp = format_time($end_time);
	$tmp =~ s/午夜|凌晨|上午|中午|下午|晚上//;
	if (!$something_done_p) {
	  $lead .= format_date($month, $day, $dow);
	  $lead .= sprintf('，喺 %s ', format_channel $channel) if $all_same_channel_p;
	  $lead .= '嘅';
	  $lead .= format_language($lang) if defined $lang;
	  $lead .= sprintf("%s：\n", ($type eq RESULT__MAIN_SEGMENT? '主要新聞時段': $type eq RESULT__LAST_NEWS_BROADCAST? '新聞時段': '節目'));
	}
	$lead .= sprintf('%s%s%s', format_time($time), ($speak_mode_p? '至': '～'), $tmp);
	$lead .= sprintf('喺 %s 播放', format_channel $channel) unless $all_same_channel_p;
	$lead .= '：'
      } else {
	if (!$something_done_p) {
	  $lead .= sprintf('%s for ', ($type eq RESULT__MAIN_SEGMENT? 'Main segment': $type eq RESULT__LAST_NEWS_BROADCAST? 'Last news broadcast': 'Schedule'));
	  $lead .= sprintf('%s programs on ', $lang) if defined $lang;
	  $lead .= format_date($month, $day, $dow);
	  $lead .= sprintf(' on %s', format_channel $channel) if $all_same_channel_p;
	  $lead .= ":\n";
	}
	$lead .= format_time($time);
	$lead .= sprintf(' on %s', format_channel $channel) unless $all_same_channel_p;
	$lead .= ': ';
	if (defined $duration && $duration) {
	  $comment = sprintf(' (%s)', format_duration $duration) unless defined $annotated{$name} && $annotated{$name} == $duration;
	  $annotated{$name} = $duration;
	}
      }
    } elsif ($flag == FLAG__UPCOMING_PROGRAM) {
      if ($chinese_p) {
	$lead .= '跟住係，' if $something_done_p;
	$lead .= sprintf('%s ', format_channel $channel) unless $all_same_channel_p;
	$lead .= '下一個節目係，' unless $something_done_p;
	$lead .= sprintf('%s播放，', format_time($time));
	if (defined $duration && $duration) {
	  $lead .= sprintf('%s嘅，', format_duration($duration)) unless defined $annotated{$name} && $annotated{$name} == $duration;
	  $annotated{$name} = $duration;
	}
      } elsif ($something_done_p) {
	$lead .= 'followed by ';
      } else {
	$lead .= sprintf('Next at %s', format_time $time);
	$lead .= sprintf(' on %s', format_channel $channel) unless $all_same_channel_p;
	$lead .= ': ';
      }
    } elsif ($flag == FLAG__CURRENT_PROGRAM) {
      if ($chinese_p) {
	$lead .= sprintf('%s ', format_channel $channel) unless $all_same_channel_p;
	$lead .= '現正播放嘅節目係：';
	$comment = sprintf('，直至%s', format_time($end_time));
      } else {
	$lead = 'Currently on';
	$lead .= sprintf(' %s', format_channel $channel) unless $all_same_channel_p;
	$lead .= sprintf(', until %s', format_time($end_time));
	$lead .= ': ';
      }
    }
    $name = $chinese_program_name{$name} if $chinese_p && defined $chinese_program_name{$name};
    communicate $lead . $name . $comment;
    $something_done_p = 1;
  }
  return scalar @$data;
}

sub announce_current_time () {
  communicate sprintf(($chinese_p? '現在係%s': 'It is now %s'), format_time POSIX::strftime('%H:%M', localtime adjusted_time));
}

sub enter_infinite_loop () {
  $query_next_program_p = 1;
  my $announcement_delta = 300;
  my $expiry_delta = 1;
  log_debug 'OMNI TV Cantonese News monitoring loop started' if $debug || $verbose;
  log_debug sprintf '[%s]', join(' ', (
	(defined $lang? "Lang=$lang": ()),
	(defined $prov? "Prov=$prov": ()),
	(defined $delta_t? "Δt=$delta_t": ()),
	#(defined $test_data_file? "TestDataFile=$test_data_file": ()),
	sprintf('%sBroadcast', $broadcast_mode_p? '+': '-'),
	sprintf('%sChinese', $chinese_p? '+': '-'),
	sprintf('%sDebug', $debug? '+': '-'),
	sprintf('%sDryRun', $dry_run_p? '+': '-'),
	#sprintf('%sGenMon', $genmon_mode? '+': '-'),
	sprintf('%sLoop', $loop_mode_p? '+': '-'),
	sprintf('%sOnce', $once_p? '+': '-'),
	sprintf('%sQuiet', $quiet_p? '+': '-'),
	sprintf('%sQueryMain', $query_main_program_p? '+': '-'),
	sprintf('%sSpeak', $speak_mode_p? '+': '-'),
	#sprintf('%sSysLine', $sysline_mode? '+': '-'),
	sprintf('%sVerbose', $verbose? '+': '-'),
      )) if $debug || $verbose;
  log_debug sprintf '[%s]', join(' ', (
	"lat=$lat",
	"lon=$lon",
      )) if $debug || $verbose;

  for (my($data, $main_program, $next_program, $start_time, $end_time, $name, $announced, $expiry, $main_program_p, $last_news_p);;) {
    my $recorded_start_time;
    $now = adjusted_time;
    my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $now;
    my $delta_minutes = 60*$hour + $min;
    my $midnight_today = POSIX::mktime(0, 0, 0, $mday, $mon, $year);
    my($reporting_origin, $reporting_delta) = ($midnight_today, $now - $midnight_today);
    if (!defined $start_time || (defined $expiry && $now > $expiry)) {
      my $previous_end_time = $end_time;
      $data = get_feed_data;
      my $full_listing = find_language_program $data, $reporting_origin;
      $main_program = filter_listing $full_listing, $reporting_origin + $reporting_delta, QUERY__MAIN;
      $next_program = filter_listing $full_listing, $reporting_origin + $reporting_delta;
      (my $flag, $start_time, $end_time, my $time, my $channel, my $dow, my $day, my $month, $name, my $duration) = @{$next_program->{'results'}->[0]} if @{$next_program->{'results'}};
      $recorded_start_time = $start_time;
      if (!defined $start_time) {
	log_debug "filter returned zero results, trying tomorrow's date" if $debug;
	$reporting_origin += 86400;
	$reporting_delta = 0;
	$full_listing = find_language_program $data, $reporting_origin;
	$main_program = filter_listing $full_listing, $reporting_origin + $reporting_delta, QUERY__MAIN;
	$next_program = filter_listing $full_listing, $reporting_origin + $reporting_delta;
	($flag, $start_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration) = @{$next_program->{'results'}->[0]} if @{$next_program->{'results'}};
      }
      if (!defined $start_time) {
	log_debug "still zero results; something is wrong" if $debug || $verbose;
      } else {
	log_debug "recorded start time $start_time, end time $end_time" if $debug;
	# Figure out real start and end times
	# FIXME this will be wrong if DST changes
	$start_time = calculate_real_time($start_time, $reporting_origin);
	$end_time = calculate_real_time($end_time, $reporting_origin);
	log_debug sprintf "real start time %d '%s', end time %d '%s'", $start_time, POSIX::strftime('%F %T', localtime $start_time), $end_time, POSIX::strftime('%F %T', localtime $end_time) if $debug;
	# If we just finished a matching program then don't bother announcing this one
	if (defined $previous_end_time && $previous_end_time == $start_time) {
	  $expiry = $end_time - $expiry_delta; # avoid re-checking main-program-p before next announcement because we just announced
	  log_debug sprintf "previous end time = start time, expiry set to %d '%s'", $expiry, POSIX::strftime('%F %T', localtime $expiry) if $debug || $verbose;
	}
      }
    }
    if (defined $main_program && @{$main_program->{'results'}}) {
	my @m = @{$main_program->{'results'}};
	my $t = $main_program->{'type'};
	($_, my $main_start_time, $_, $_, $_, $_, $_, $_, my $name1, $_) = @{$m[0]};
	($_, $_, my $main_end_time, $_, $_, $_, $_, $_, my $name2, $_) = @{$m[$#m]};
	my $det = $delta_minutes + $announcement_delta/60; # we can't just use $delta_minutes because announcement is a few minutes before
	my $inside_p = $main_start_time <= $det && $det <= $main_end_time;
	$main_program_p = $inside_p && $t eq RESULT__MAIN_SEGMENT;
	$last_news_p = $inside_p && $t eq RESULT__LAST_NEWS_BROADCAST;
	$next_program = $main_program if $main_program_p;
    }
    my $dt = $start_time - $now;
    my $sleep_time;
    log_debug sprintf "delta to next program = %d (start time %d '%s')", $start_time - $now, $start_time, POSIX::strftime('%F %T', localtime $start_time) if $debug;
    if ($dt <= $announcement_delta && (!defined $announced || $announced < $start_time - $announcement_delta)) {
      my $night_p = POSIX::strftime('%H', localtime $now) =~ /^0[0-7]$/;
      if ($quiet_p && $night_p && $speak_mode_p) {
	log_debug "an announcement would have been made but it's night and we're in quiet mode" if $debug || $verbose;
      } elsif ($query_main_program_p && !$main_program_p) {
	log_debug "an announcement would have been made but it's not the main program and we're told to look for that" if $debug || $verbose;
      } elsif ($dt < 0 && $speak_mode_p) { # program already started - don't bother announcing
	;
      } else {
	start_talking;
	announce_current_time;
	display_listing $next_program, $now;
	communicate($chinese_p? '呢個係今日嘅主要新聞時段': "This is today's main broadcast") if $main_program_p;
	communicate($chinese_p? '呢個係今日最後一次新聞時段': "This is today's last news broadcast") if $last_news_p;
	stop_talking;
	turn_tv_on if $main_program_p || $last_news_p;
    last if $once_p;
      }
      $announced = $now;
      $expiry = $end_time - $announcement_delta - $expiry_delta; # must re-check main-program-p before announcement
      $sleep_time = $expiry - $now;
      log_debug sprintf "remembered announced time, expiry set to %d '%s', sleep time set to %d", $expiry, POSIX::strftime('%F %T', localtime $expiry), $sleep_time if $debug || $verbose;
    } else {
      $sleep_time = $dt if $sleep_time > $dt;
      $sleep_time /= 2;
      $sleep_time = 1 if $sleep_time < 1;
    }
    if (defined $sleep_time) {
      $sleep_time = 1  if $sleep_time < 1;
      log_debug "sleep $sleep_time" if $debug;
      sleep $sleep_time;
    }
  }
}

sub usage (;$) {
  my($st) = @_; my $h = $st? *STDERR: *STDOUT;
  my $url = feed_url;
  print $h <<EOF;
Usage: $0 [OPTION]...
Figure out when OMNI News Cantonese is being aired by checking the scheduile.

  -A, --all                   Match all programs instead of a specific language
  -I, --data-file=FILE        Use test feed data in specified FILE
  -g, --genmon                Terse format suitable as two-line genmon input
  -n, --next                  Display next match instead of all matches
      --once                  DEBUGGING ONLY: Exit loop after first annoucement
      --province=CODE         Use the province identified by the specified CODE
  -q, --quiet                 Do not use speech synthesis after midnight
      --speak                 Speak the result instead of displaying it
  -w, --sysline               Terse format suitable as a sysline .who file
  -W, --what-if=TIMESTAMP     Pretend current time is TIMESTAMP (Unix epoch)
  -v, --verbose               Explain what is being done
  -z, --chinese               Display (or speak) results in Chinese
      --debug                 Produce lots of debugging output (can be specified
                              more than once for additional verbosity)

The codes bc and on are known to exist, but it's not known if they air different
programs in different provinces.

The schedule does not indicate what language a program is aired in so we're
really just guessing.  It is also sometimes wrong; to double check, go to
$url
EOF
  exit $st;
}

Getopt::Long::config('bundling');
GetOptions(
  'A|all' => sub { $lang = undef },
  'b|broadcast' => \$broadcast_mode_p,
  'd|debug' => sub { $debug += 1 },
  'dry-run' => \$dry_run_p,
  'province=s' => \$prov,
  'I|data-file=s' => \$test_data_file,
  'g|genmon' => \$genmon_mode,
  'loop' => \$loop_mode_p,
  'n|next' => \$query_next_program_p,
  'once' => \$once_p,
  'q|quiet' => \$quiet_p,
  's|speak' => \$speak_mode_p,
  'T|today' => \$query_main_program_p,
  'w|sysline' => \$sysline_mode,
  'W|what-if=i' => sub { my($key, $val) = @_; $delta_t = $val - time; },
  'v|verbose' => \$verbose,
  'z|zh|chinese' => \$chinese_p,
  'help' => \&usage,
) || usage(1);

die "$0: \"$prov\" does not look like a valid city code\n" unless $prov =~ /^[a-z]{2}$/;
$now = adjusted_time;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

my $coords = guess_coordinates;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

if ($loop_mode_p) {
  enter_infinite_loop;
} else {
  my $data = get_feed_data;
  log_debug('parsed data is ' . Dumper $data) if $debug;

  my $reporting_origin = $now;
  my $full_listing = find_language_program $data, $reporting_origin;
  my $listing = filter_listing $full_listing, $reporting_origin;

  if ($query_next_program_p && !@{$listing->{'results'}}) {
    my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($now + 82800); # 23 hours, to avoid DST issues
    $reporting_origin = POSIX::mktime(0, 0, 0, $mday, $mon, $year);
    log_debug "no results were found, adjusting reporting origin to $reporting_origin" if $debug || $verbose;
    $full_listing = find_language_program $data, $reporting_origin;
    $listing = filter_listing $full_listing, $reporting_origin;
  }
  display_listing $listing, $reporting_origin
      or print "No results were found.\n";
}
