#!/usr/bin/perl
# vi:set sw=2 ai sm:
#
# Copyright 2021–2024 by Ambrose Li <ambrose.li@gmail.com>
# Pull program schedule from OMNI TV's site to try to figure out when news is aired
# because the time can shift around or news for the day can get cancelled for hockey
#
# Feed for Toronto is here: https://www.omnitv.ca/on/yue-can/schedule/
# Province probably makes a difference, but language doesn't because this is just the master schedule
# The schedule is a mess of spans and b's (not even divs) that's completely unreadable on w3m

# References (for say(1)):
# https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/FineTuning/FineTuning.html
# https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/SpeechSynthesisProgrammingGuide/Phonemes/Phonemes.html

# To investigate:
# https://www.mattmontag.com/personal/mac-os-x-speech-synthesis-markup
# https://developer.apple.com/documentation/applicationservices/1552235-texttophonemes [API reference, requires Javascript]
# https://developer.apple.com/documentation/appkit/nsspeechphonemeinfoexample?language=objc
# https://developer.apple.com/audio/
# https://developer.apple.com/documentation/avfaudio/avaudiosession/capturing_stereo_audio_from_built-in_microphones
# https://stackoverflow.com/questions/37529/simple-audio-input-api-on-a-mac
# -> http://www.portaudio.com/
# -> https://github.com/PortAudio/portaudio
# https://github.com/espeak-ng/espeak-ng/

# Historical knowledge only:
# https://github.com/zonque/PulseAudioOSX

# Future use only:
# https://www.musicradar.com/news/someone-finally-came-up-with-a-soundflower-replacement-and-its-free-for-mac-users
# -> https://github.com/ExistentialAudio/BlackHole/releases

# see https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default for these crazy hacks
# THERE ARE MORE CRAZY HACKS THERE FOR MORE COMPLEX PROJECTS!!
use v5.12; # minimal for unicode string feature
#use v5.14; # //u modifier
use utf8;
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );
use feature "unicode_strings";

use warnings qw( FATAL utf8 );
use Encode qw( encode decode );
@ARGV = map { decode("UTF-8", $_) } @ARGV if grep /\P{ASCII}/ => @ARGV;


use strict;
use integer;
use feature 'state';

use POSIX ":sys_wait_h";
use Data::Dumper;
use Getopt::Long;

use vars qw( $debug $test_data_file );
use vars qw( $verbose );
use vars qw( $lang );
use vars qw( $prov );
use vars qw( $now );
use vars qw( $delta_t );
use vars qw( $chinese_p );
use vars qw( $loop_mode_p );
use vars qw( $show_languages_p );
use vars qw( $once_p );
use vars qw( $dry_run_p );
use vars qw( $query_next_program_p );
use vars qw( $query_main_program_p );
use vars qw( $speak_mode_p );
use vars qw( $broadcast_mode_p );
use vars qw( $quiet_p );
use vars qw( $buffered_speech_p $buffered_speech );
use vars qw( $preferred_English_voice );
use vars qw( $omni_1_p );
$lang = 'CAN';
$prov = 'on';

use vars qw( $data_dir $temp_file $esd_server $pa_server $pa_sink );
$data_dir = "$ENV{HOME}/.cache/omni-news";
$temp_file = "$data_dir/temp.wav";
#$esd_server = 'pingviini';
($pa_server, $pa_sink) = ('osmc', 'rtp');

use vars qw( $config_dir $config_file $config_file_fallback $config );
$config_dir = "$ENV{HOME}/.config/omni-news";
$config_file = "$config_dir/config";
$config_file_fallback = "$ENV{HOME}/.omni-newsrc";

use vars qw( $max_staleness );
$max_staleness = 3*86400; # 3 days - the published schedule spans 2 weeks so in theory this number can be even bigger but just in case

use vars qw( $max_sleep );
$max_sleep = 3600; # 30 minutes

sub STATE__INITIAL   () { 'INITIAL' }
sub STATE__DAYS      () { 'DAYS' }
sub STATE__DAY       () { 'DAY' }
sub STATE__DURATION  () { 'DURATION' }
sub STATE__SCHEDULE  () { 'SCHEDULE' }
sub STATE__SHOW_NAME () { 'SHOW_NAME' }
sub STATE__LIMINAL   () { 'LIMINAL' }
sub STATE__FOOTER    () { 'FOOTER' }

# New schedule is language tagged using strange OMNI codes (not ISO 639, not BCP):
# ARA = Arabic
# BEN = Bengali
# CAN = Cantonese
# ENG = English
# EST = Estonian
# KOR = Korean
# MAA = Mandarin
# PAN = Punjabi
# PER = Persian
# SNM = Sinhala? (Sri Lanka)
# SOM = Somalian?
# TAG = Tagalog
# TUR = Turkish
# VIE = Vietnamese
#   grep language-tag ~/.cache/omni-news/on.html |cut -d\> -f2|cut -d\< -f1|sort|uniq
use vars qw( %langs );
%langs = (
  #'AMH' => { 'en' => 'Amharic', 'zh' => '?' },			# ?
  #'AKA' => { 'en' => 'Ghanian', 'zh' => '加納文' },		# ?
  'ARA' => { 'en' => 'Arabic', 'zh' => '阿拉伯文' },
  'ARM' => { 'en' => 'Armenian', 'zh' => '亞美尼亞文' },
  'BEN' => { 'en' => 'Bengali', 'zh' => '孟加拉文' },
  'CAN' => { 'en' => 'Cantonese', 'zh' => '廣東話' },
  #'CPE' => { 'en' => '???', 'zh' => '???' },			# "Phina"?
  #'CPF' => { 'en' => '???', 'zh' => '???' },			# African French?
  'CZE' => { 'en' => 'Czech', 'zh' => '捷克文' },
  #'DIN' => { 'en' => '???', 'zh' => '???' },
  'EST' => { 'en' => 'Estonian', 'zh' => '愛沙尼亞文' },
  'GRE' => { 'en' => 'Greek', 'zh' => '希臘文' },
  'HIN' => { 'en' => 'Hindi', 'zh' => '印度文' },
  'HUN' => { 'en' => 'Hungarian', 'zh' => '匈牙利文' },
  'ITA' => { 'en' => 'Italian', 'zh' => '意大利文' },
  'JPN' => { 'en' => 'Japanese', 'zh' => '日文' },
  'KOR' => { 'en' => 'Korean', 'zh' => '韓文' },
  'MAA' => { 'en' => 'Mandarin', 'zh' => '北方話' },
  'MAC' => { 'en' => 'Macedonian', 'zh' => '北馬其頓文' },
  #'MAL' => { 'en' => '???', 'zh' => '???' },
  'MLT' => { 'en' => 'Maltese', 'zh' => '馬爾他文' },
  'PAN' => { 'en' => 'Punjabi', 'zh' => '旁遮普文' },
  'PER' => { 'en' => 'Persian', 'zh' => '波斯文' },
  'POR' => { 'en' => 'Portuguese', 'zh' => '萄文' },
  'RUM' => { 'en' => 'Romanian', 'zh' => '羅馬尼亞文' },
  'RUS' => { 'en' => 'Russian', 'zh' => '俄文' },
  'SCC' => { 'en' => 'Serbo-Croatian', 'zh' => '塞爾維亞-克羅地亞文' },
  'SNH' => { 'en' => 'Sinhala', 'zh' => '僧伽羅文' },
  'SLO' => { 'en' => 'Slovenian', 'zh' => '斯洛文尼亞文' },
  'SOM' => { 'en' => 'Somalian', 'zh' => '索馬里文' },
  'SPA' => { 'en' => 'Spanish', 'zh' => '西班牙文' },
  'TAG' => { 'en' => 'Filipino', 'zh' => '菲律賓文' },
  'TAM' => { 'en' => 'Tamil', 'zh' => '塔米爾文' },
  #'TEL' => { 'en' => 'Telegu', 'zh' => '???' },
  'TUR' => { 'en' => 'Turkish', 'zh' => '土耳其文' },
  'UKR' => { 'en' => 'Ukrainian', 'zh' => '烏克蘭文' },
  'URD' => { 'en' => 'Urdu', 'zh' => '烏爾j都文' },
  'VIE' => { 'en' => 'Vietnamese', 'zh' => '越南文' },
  #'YOR' => { 'en' => '???', 'zh' => '???' },
);

use vars qw( %months %dows %dow_numbers %dow_codes );
%months = (
  'Jan' => ['January', '一月'],
  'Feb' => ['February', '二月'],
  'Mar' => ['March', '三月'],
  'Apr' => ['April', '四月'],
  'May' => ['May', '五月'],
  'Jun' => ['June', '六月'],
  'Jul' => ['July', '七月'],
  'Aug' => ['August', '八月'],
  'Sep' => ['September', '九月'],
  'Oct' => ['October', '十月'],
  'Nov' => ['Novermber', '十一月'],
  'Dec' => ['December', '十二月'],
);
%dows = (
  'Monday' => ['Monday', '星期一'],
  'Tuesday' => ['Tuesday', '星期二'],
  'Wednesday' => ['Wednesday', '星期三'],
  'Thursday' => ['Thursday', '星期四'],
  'Friday' => ['Friday', '星期五'],
  'Saturday' => ['Saturday', '星期六'],
  'Sunday' => ['Sunday', '星期日'],
);
%dow_numbers = (
  'Monday' => 1,
  'Tuesday' => 2,
  'Wednesday' => 3,
  'Thursday' => 4,
  'Friday' => 5,
  'Saturday' => 6,
  'Sunday' => 7,
);
%dow_codes = (
  'Monday' => ['M', '一'],
  'Tuesday' => ['T', '二'],
  'Wednesday' => ['W', '三'],
  'Thursday' => ['R', '四'],
  'Friday' => ['F', '五'],
  'Saturday' => ['S', '六'],
  'Sunday' => ['U', '日'],
);

use vars qw( %words );
%words = (
  0 => ['zero', 'zeroeth'],
  1 => ['one', 'first'],
  2 => ['two', 'second'],
  3 => ['three', 'third'],
  4 => ['four', 'fourth'],
  5 => ['five', 'fifth'],
  6 => ['six', 'sixth'],
  7 => ['seven', 'seventh'],
  8 => ['eight', 'eighth'],
  9 => ['nine', 'ninth'],
  10 => ['ten', 'tenth'],
  11 => ['eleven', 'eleventh'],
  12 => ['twelve', 'twelfth'],
  13 => ['thirteen', 'thirteenth'],
  14 => ['fourteen', 'fourteenth'],
  15 => ['fifteen', 'fifteenth'],
  16 => ['sixteen', 'sixteenth'],
  17 => ['seventeen', 'seventeenth'],
  18 => ['eighteen', 'eighteenth'],
  19 => ['nineteen', 'nineteenth'],
  20 => ['twenty', 'twentieth'],
  30 => ['thirty', 'thirtieth'],
  40 => ['forty', 'fortieth'],
  50 => ['fifty', 'fiftieth'],
);

use vars qw( %channel_pronunciations );
%channel_pronunciations = (
  # XXX This is hopeless. The Sin Ji voice cannot pronounce English, but there is no support for English phonemes
  'omni1' => ['Omni One', 'Omni One'],
  'omni2' => ['Omni Two', 'Omni Two'],
);

# FIXME In theory we can poll https://www.omnitv.ca/on/en/shows/ but the page is pure JS that doesn't even work on Brave (even with shields down)
use vars qw( %chinese_program_name );
%chinese_program_name = (
  'OMNI News: Cantonese Edition' => '粵語新聞',
  'Focus Cantonese' => '都市聚焦',
  'Showers of Blessings' => '恩雨之聲',	# third-party program (SOBEM)
  'Close to Culture' => '拉近文化',	# third-party program (iCable)
);

use vars qw( $lat $lon );
use vars qw( $use_datetime_event_sunrise );
use vars qw( $use_datetime_astro_sunrise );
use vars qw( $use_astro_sunrise );
BEGIN {
  if (eval { require DateTime::Event::Sunrise; }) {
    $use_datetime_event_sunrise = 1;
  } elsif (eval { require DateTime::Astro::Sunrise; }) {
    $use_datetime_astro_sunrise = 1;
  } elsif (eval { require Astro::Sunrise; }) {
    $use_astro_sunrise = 1;
  } else {
    die "Cannot find a usable Sunrise package";
  }
}

sub log_something ($$) {
  my($msg, $flag) = @_;
  chomp $msg;
  for my $s (split(/\n/, $msg)) {
    printf STDERR "%d%s\t%s\n", time, $flag, $s;
  }
}

sub log_debug ($) {
  return log_something $_[0], '#';
}

sub log_input ($) {
  return log_something $_[0], '<';
}

sub log_output ($) {
  return log_something $_[0], '>';
}

sub show_cmd (\@;$) {
  my($cmd, $dry_run_p) = @_;
  log_debug sprintf '%s: %s', (defined $dry_run_p && $dry_run_p? 'pretending to run': 'running'), join(' ', map { /'/? (/"/? eval {
	s/"/\\"/;
	"\"$_\"";
      }: "\"$_\""): /\s/? "'$_'": $_ } @$cmd) if $debug || $verbose;
}

# NOTE: this is chimer's version, copied straight from chimer
# NOTE: modified to act like the current PHP version (root section goes to /, duplicate keys allowed and get stashed into an array)
sub read_ini ($) {
  my($input) = @_;
  my $it;
  local(*INPUT, $.);
  if (open(INPUT, '<:utf8', $input)) {
    for (my $section = '/';;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^\s*(?:[#\%;]|$)/) {
        ;
      } elsif ($s =~ /^\s*\[\s*([^\[\]]+?)\s*\]\s*$/) {
        $section = $1;
      } elsif ($s =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
        if (defined $section) {
          $it->{$section}->{$1} = [] unless defined $it->{$section}->{$1};
          push @{$it->{$section}->{$1}}, $2;
        } else {
          $it->{$1} = [] unless defined $it->{$1};
          push @{$it->{$1}}, $2;
        }
      } else {
        warn "$input:$.: Warning: Unknown input \"$s\"\n";
      }
    }
    close INPUT;
  }
  return $it;
}

sub RUN_CMD__IGNORE_ERRORS  () { 1 }
sub RUN_CMD__IGNORE_SIGNALS () { 2 }

sub run_cmd_real (\@;$) {
  my($cmd, $opt) = @_;
  show_cmd @$cmd;
  #my $st = system { $cmd->[0] } @$cmd;
  my $pid = open(CMD, '-|');
  my($msg, $fatal_p);
  if (!defined $pid) {
    $msg = sprintf("%s: fork: %s\n", $cmd->[0], $!);
    $fatal_p = defined $opt && ($opt & RUN_CMD__IGNORE_ERRORS);
  } elsif (!$pid) {
    POSIX::dup2(1, 2); # redirect stderr to stdout
    exec { $cmd->[0] } @$cmd;
    die sprintf("%s: exec: %s\n", $cmd->[0], $!);
  }
  for (;;) {
    my $s = scalar <CMD>;
  last unless defined $s;
    log_input $s;
  }
  close CMD;
  my $st = waitpid($pid, 0);

  # Try to be reasonable when it comes to allowing ^C to do its thing but ignoring errors
  # NOTE: POSIX::WIFEXITED and POSIX::WIFSIGNALED sound like good ideas, in reality they don't work
  if ($st & 127) {
    $msg = sprintf('Command %s killed by signal %d', $cmd->[0], $st & 127);
    $fatal_p = defined $opt && ($opt & RUN_CMD__IGNORE_SIGNALS);
  } elsif ($st) {
    $msg = sprintf('Command %s returned exit status %d', $cmd->[0], $st >> 8);
    $fatal_p = defined $opt && ($opt & RUN_CMD__IGNORE_ERRORS);
  }
  if (defined $msg) {
    die "Unexpected error: $msg\n" if defined $fatal_p && $fatal_p;
    log_debug $msg;
  }
  return $st;
}

sub run_cmd (\@;$) {
  my($cmd, $opt) = @_;
  if ($dry_run_p) {
    show_cmd @$cmd, $dry_run_p;
  } else {
    run_cmd_real @$cmd, $opt;
  }
}

sub turn_tv_on () {
  my @cmd = ('ssh', '-T', '-l', 'tv-on');
  my $id = sprintf('%s/.ssh/tvcontrol', $ENV{'HOME'});
  push @cmd, ('-i', $id) if -f $id;
  push @cmd, 'osmc';
  return run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
}

sub turn_tv_off () {
  my @cmd = ('ssh', '-T', '-l', 'tv-off');
  my $id = sprintf('%s/.ssh/tvcontrol', $ENV{'HOME'});
  push @cmd, ('-i', $id) if -f $id;
  push @cmd, 'osmc';
  return run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
}

sub estimate_sunrise ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->start;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[0];
    $it = $tmp->strftime('%s');
  } else {
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunrise;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub estimate_sunset ($) {
  my($t) = @_;
  my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime $t;
  my $dt = DateTime->new(year => $year + 1900, month => $mon + 1, day => $mday) if $use_datetime_event_sunrise || $use_datetime_astro_sunrise;
  my $tmp;
  my $it;
  if ($use_datetime_event_sunrise) {
    my $sunrise = DateTime::Event::Sunrise->new(latitude => $lat, longitude => $lon, precise => 1);
    $tmp = $sunrise->sunrise_sunset_span($dt)->end;
    $it = $tmp->strftime('%s');
  } elsif ($use_datetime_astro_sunrise) {
    my $sunrise = DateTime::Astro::Sunrise->new($lat, $lon, undef, 1);
    $tmp = ($sunrise->sunrise($dt))[1];
    $it = $tmp->strftime('%s');
  } else {
    # this should be the same as the else case in estimate_sunrise except the last line
    no integer;
    my $tz = ($2 + $3/60) * ($1 eq '-'? -1: 1) if POSIX::strftime('%z', localtime $t) =~ /^([-\+])(\d\d)(\d\d)$/;
    my($sunrise, $sunset) = Astro::Sunrise::sunrise($year + 1900, $mon + 1, $mday, $lon, $lat, $tz, $isdst);
    $tmp = $sunset;
    $it = POSIX::mktime(0, $2, $1, $mday, $mon, $year) if $tmp =~ /^(\d\d):(\d\d)$/;
  }
  return $it;
}

sub guess_city () {
  my $input = '/etc/localtime';
  my $det = readlink $input;
  die "$input: $!\n" unless defined $det;
  return $1 if $det =~ /([^\/]+)$/s;
}

sub guess_coordinates () {
  my $it;
  my $city = guess_city;
  log_debug "guessed city=($city)" if $debug;
  my @cmd = qw(hebcal cities);
  show_cmd @cmd if $debug;
  my $pid = open(INPUT, '-|');
  die "$0: guess_coordinates: $cmd[0]: fork: $!\n" unless defined $pid;
  if ($pid) {
    my $re = q{(?=\S)[^()]+(?<=\S)};
    for (;;) {
      my $s = scalar <INPUT>;
    last unless defined $s;
      chomp $s;
      if ($s =~ /^($re) \((\d+)d(\d+)' ([NS]) lat, (\d+)d(\d+)' [EW] long/) {	# original hebcal
	my($det, $lat_deg, $lat_min, $lat_dir, $lon_deg, $lon_min, $lon_dir) = ($1, $2, $3, $4, $5, $6, $7);
	if ($det eq $city) {
	  no integer;
	  $it = {
		'lat' => ($lat_deg + $lat_min/60)*($lat_dir eq 'N'? 1: -1),
		'lon' => ($lon_deg + $lon_min/60)*($lon_dir eq 'E'? 1: -1),
	      };
	}
      } elsif ($s =~ /^($re) \((-?\d+(\.\d+)?),(-?\d+(\.\d+)?)  /) {		# new Go-based hebcal (5.8.1)
	my($det, $lat, $lon) = ($1, $2, $3);
        no integer;
	if ($det eq $city) {
	  $it = {
		'lat' => ($lat + 0),
		'lon' => ($lon + 0),
	      };
	};
      } else {
	die "$cmd[0]:$.: Unknown input \"$s\"\n";
      }
    last if defined $it;
    }
    close INPUT;
  } else {
    exec {$cmd[0]} @cmd;
    die "$0: guess_coordinates: $cmd[0]: exec: $!\n";
  }
  return $it;
}

sub adjusted_time () {
  my $t = time;
  $t += $delta_t if defined $delta_t;
  return $t;
}

sub in_words ($;$) {
  my($n, $ordinal_p) = @_;
  my $it;
  $ordinal_p = 0 if !defined $ordinal_p;
  if (defined $words{$n}) {
    $it = $words{$n}->[$ordinal_p];
  } elsif (defined $words{+my $det = 10*int($n/10)}) {
    $it = sprintf('%s-%s', $words{$det}->[0], $words{+$n%10}->[$ordinal_p]);
  }
  die "Can't put \"$n\" in words" unless defined $it;
  return $it;
}

sub format_date ($$$) {
  my($month, $day, $dow) = @_;
  my $fmt = $chinese_p? '%s%s日%s': $speak_mode_p? '%3$s %1$s %2$s': '%3$s, %1$s %2$s';
  my $s = sprintf $fmt, $months{$month}->[$chinese_p], $day, $dows{$dow}->[$chinese_p];
  $s =~ s{(\d+)$}{ 'the ' . in_words($1, 1) }se if !$chinese_p && $speak_mode_p;
  return $s;
}

sub format_time ($;$) {
  my($time, $short_p) = @_;
  my($hour, $minute) = $time =~ /^(\d\d):(\d\d)$/? ($1 + 0, $2 + 0): $time =~ /^(\d+)$/? ($time/60, $time%60): undef;
  ($_, $_, $_, my $mday, my $mon, my $year) = localtime $now;
  my $midnight_today = POSIX::mktime(0, 0, 0, $mday, $mon, $year);
  my $t = POSIX::mktime(0, $minute, $hour, $mday, $mon, $year);
  my $sunrise = estimate_sunrise $now;
  my $sunset = estimate_sunset $now;
  my $before_sunrise_p = $t < $sunrise;
  my $after_sunset_p = $t >= $sunset;
  my $it;
  if ($chinese_p) {
    my $h = ($hour + 11)%12 + 1;
    my $m = $minute;
    if ($speak_mode_p) {
      $h = ($speak_mode_p? '兩': '二') if $h == 2;
      if ($m == 2) {
	$m = '零二';
      } elsif ($m && $m < 10) {
	$m = "零$m";
      }
    }
    my $fmt = $speak_mode_p? '%s%s點': '%s%s時';
    $it = sprintf($fmt, ($hour == 0 && $minute == 0? '午夜': $hour == 12 && $minute == 0? '中午': $before_sunrise_p? '凌晨': $after_sunset_p? '晚上': $hour < 12? '上午': '下午'), $h);
    if ($minute == 30) {
      $it .= '半';
    } elsif ($minute) {
      $it .= sprintf('%s分', $m);
    }
  } else {
    my($fmt1, $fmt2) = $speak_mode_p? (sub { in_words($_[0]) }, sub { in_words($_[0]) }): ('%2d:', '%02d');
    # mimic3 speaks "pm" (consonant cluster with no vowel) even with periods if written "p.m."
    # since we are calculating sunrise and sunset, it's best to avoid a.m. and p.m. completely
    my($am, $pm, $noon, $midnight) = $speak_mode_p? ('in the morning', ($after_sunset_p? 'in the evening': 'in the afternoon'), 'noon', 'midnight'): ('am', 'pm', 'pm', 'am');
    my $display_hour = ($hour + 11)%12 + 1;
    $it = ref $fmt1? &$fmt1($display_hour) . ' ': sprintf($fmt1, $display_hour);
    $it .= ref $fmt2? &$fmt2($minute) . ' ': sprintf($fmt2, $minute) if !$speak_mode_p || $minute;
    $it .= ($hour == 0? $midnight: $hour < 12? $am: $hour == 12? $noon: $pm) unless $short_p;
  }
  return $it =~ s/\s+$//sr;
}

sub format_duration ($) {
  my($minutes) = @_;
  my $it;
  if ($minutes) { # the schedule is so inaccurate that some programs are marked as duration0
    my $hours = $minutes/60;
    $minutes %= 60;
    $it .= sprintf(($chinese_p? '%s 小時': '%s %s'), $hours, ($hours == 1? 'hour': 'hours')) if $hours;
    $it .= sprintf(($chinese_p? '%s 分鐘': '%s %s'), $minutes, ($minutes == 1? 'minute': 'minutes')) if $minutes;
  }
  return $it;
}

sub format_channel ($) {
  my($channel) = @_;
  return $speak_mode_p && defined $channel_pronunciations{$channel}->[$chinese_p]? $channel_pronunciations{$channel}->[$chinese_p]: uc $channel;
}

sub format_language ($) {
  my($lang) = @_;
  return defined $langs{$lang}? $langs{$lang}->{+$chinese_p? 'zh': 'en'}: $lang;
}

sub calculate_real_time ($;$) {
  my($delta_min, $origin) = @_;

  # In theory we can just return $origin + 60*$delta_min, in practice this is wrong because DST is a thing
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(defined $origin? $origin: $now);
  if (!defined $origin) {
    $origin = POSIX::mktime(0, 0, 0, $mday, $mon, $year) unless defined $origin;
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $origin;
  }
  return POSIX::mktime(0, $delta_min%60, $delta_min/60, $mday, $mon, $year);
}

sub macos_p () {
  return -f '/mach_kernel';
}

sub preferred_English_voice () {
  if (!defined $preferred_English_voice) {
    if (macos_p) {
      my %voices;
      my @cmd = ('say', '-v', '?');
      show_cmd @cmd;

      my $h = open(INPUT, '-|');
      die "$0: $cmd[0]: fork: $!\n" unless defined $h;
      if ($h) {
	for (;;) {
	  my $s = scalar <INPUT>;
	last unless defined $s;
	  $voices{$1} = $2 if $s =~ /^(.*?\S)\s+([a-z]{2}[-_](?:[A-Z][A-Z]|[a-z]+))\s+#/s;
	}
	close INPUT;
      } else {
	exec {$cmd[0]} @cmd;
	die "$0: $cmd[0]: exec: $!\n";
      }
      for my $pref (('Fiona', 'Emily', 'Karen', 'Samantha')) {
	$preferred_English_voice = $pref if defined $voices{$pref};
      last if defined $preferred_English_voice;
      }
    } else {
      # XXX stupid hack
      $preferred_English_voice = -f '/usr/share/mbrola/us1'? 'mb-us1': 'en';
    }
  }
  return $preferred_English_voice;
}

sub start_talking () {
  $buffered_speech_p = 1;
}

sub communicate ($) {
  my($s) = @_;
  my @cmd;
  # NOTE: The following comment applies to MacOS only (my current setup is Ubuntu + RaspOS (Piper) so MacOS is no longer tested):
  # DVD quality = 48k = 49152, CD = 44.1k = 50×294×3  = 44100, tape = 32k = 32768, AM radio = 22.05k (= 22050?), phone = 8k = 8192
  # Passing most of these to --bit-rate doesn't actually work; in particular, setting it to 8k will appear to work but produce silence.
  # Default rate seems to be 22050, but explicitly setting it to 22050 will give "Setting bit rate failed: prop"; I hate Apple.
  my @opts = (macos_p? ('--file-format', 'WAVE', '--data-format', 'ulaw', '-o', $temp_file): ('-w', $temp_file)) if $broadcast_mode_p;
  my $pause = '[[slnc 1000]]' if macos_p;
  my $force_temp_file_p = 0;
  if ($speak_mode_p) {
    # stupid hacks to make TTS do the right thing
    $s =~ s/\bOMNI\b/Omni/sg;
    $s =~ s/(?<=\btele)(?=kids)/-/sgi;
    $s .= ' ' if $s =~ /\.$/s;
  }
  if (!$speak_mode_p) {
    log_output $s if $debug;
    printf "%s\n", $s;
  } elsif ($buffered_speech_p) {
    if (defined $buffered_speech) {
      $buffered_speech .= '。' if $chinese_p && $buffered_speech !~ /(?:，|。|！|？)$/s;
      $buffered_speech .= $s =~ /^[a-z]/? ';': '.' if !$chinese_p && $buffered_speech !~ /[\.,:;!\?]\s*$/s;
    }
    $buffered_speech .= ' ' if !$chinese_p && defined $buffered_speech && $buffered_speech !~ /\s$/s;
    $buffered_speech .= $s;
  } elsif (macos_p && $chinese_p) {
    @cmd = ('say', @opts, '-v', 'Sin-Ji', $s, $pause);
  } elsif (macos_p) {
    @cmd = ('say', @opts, '-v', preferred_English_voice, $s, $pause);
  } else {
    # This is hard-coded for now. If you have a better TTS program (e.g., Mimic3 or Piper) just write a script and name it espeak
    @cmd = ('espeak', @opts, '-v', preferred_English_voice, $s);
  }
  if (@cmd) {
    run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
    if ($broadcast_mode_p || $force_temp_file_p) {
      if (defined $pa_server) {
	@cmd = ('paplay', '-s', $pa_server, (defined $pa_sink? ('-d', $pa_sink): ()), $temp_file);
      } else {
	@cmd = ('esdplay', '-s', $esd_server, $temp_file);
      }
      run_cmd @cmd, RUN_CMD__IGNORE_ERRORS;
    }
  }
}

sub stop_talking () {
  if ($buffered_speech_p) {
    $buffered_speech_p = 0;
    $buffered_speech .= '.' if $speak_mode_p && !$chinese_p && $buffered_speech !~ /[\.!\?]['"’”]*\s*$/s;
    communicate $buffered_speech;
  }
  $buffered_speech = undef;
}

sub feed_url () {
  # New schedule:
  # OMNI 1: https://www.omnitv.ca/tv-schedule/?region=omni1
  # OMNI 2 Eastern: https://www.omnitv.ca/tv-schedule/?region=eastern
  # OMNI 2 Pacific: https://www.omnitv.ca/tv-schedule/?region=pacific
  # OMNI 2 Prairies: https://www.omnitv.ca/tv-schedule/?region=prairies
  return $omni_1_p? 'https://www.omnitv.ca/tv-schedule/?region=omni1':
	 $prov =~ /(?:bc)/i? 'https://www.omnitv.ca/tv-schedule/?region=pacific':
	 $prov =~ /(?:on)/i? 'https://www.omnitv.ca/tv-schedule/?region=eastern':
	 $prov =~ /(?:ab)/i? 'https://www.omnitv.ca/tv-schedule/?region=prairies':
	 undef;
}

sub data_file () {
  my $basename = $omni_1_p? "1.html": "$prov.html";
  my $data_file;
  if (!-d $data_dir) {
    mkdir $data_dir or warn "$0: $data_dir: $!\n";
  }
  $data_file = "$data_dir/$basename";
  return $data_file;
}

sub get_feed_data (;$) {
  my($force_p) = @_;
  my $data_file;
  state $last_attempted_time;
  my $min_attempt_delay = 600;
  if (defined $last_attempted_time && time - $last_attempted_time < $min_attempt_delay) {	# don't hammer the server
    log_debug "forcing delay of $min_attempt_delay seconds";
    sleep $min_attempt_delay;
  }
  if (defined $test_data_file) {
    $data_file = $test_data_file;
    log_debug "using test data from \"$data_file\"" if $debug || $verbose;
  } else {
    $data_file = data_file;
    my $use_cached_data = 0;
    if (!-f $data_file) {
      log_debug 'need to get new data because nothing was cached' if $debug || $verbose;
    } elsif (time - (stat $data_file)[9] > $max_staleness) {
      log_debug 'need to get new data because cache was stale' if $debug || $verbose;
    } elsif ((stat $data_file)[7] == 0) {
      log_debug 'need to get new data because cache file was empty' if $debug || $verbose;
    } elsif (defined $force_p && $force_p) {
      log_debug sprintf 'need to get new data because %s', (!ref $force_p && $force_p =~ /\D/s? $force_p: 'we were told to') if $debug || $verbose;
    } else {
      log_debug "using cached data in $data_file" if $debug;
      $use_cached_data = 1;
    }
    if (!$use_cached_data) {
      my @cmd = ('wget', '-q', '-O', $data_file, feed_url);
      $last_attempted_time = time unless $force_p;
      show_cmd @cmd;
      my $pid = fork;
      die "$0: get_feed_data: $cmd[0]: fork: $!\n" unless defined $pid;
      if (!$pid) {
	exec {$cmd[0]} @cmd;
	die "$0: get_feed_data: $cmd[0]: exec: $!\n";
      }
      wait; # otherwise we'll try to open the file before wget saves it
    }
  }
  open(INPUT, '<:utf8', $data_file) or die "$0: $data_file: $!\n";
  my $it = {};
  my $regs = {};
  my @readahead;
  for (my $state = STATE__INITIAL, my $i = -1, my $node;;) {
    my $s = @readahead? pop @readahead: scalar <INPUT>;
  last unless defined $s;
    chomp $s;
    $s =~ s/^\s+//s;
    log_debug "state $state" if $debug > 2;
    log_input $s if $debug > 2;
    $s =~ s/\&#039;/’/g;
    $s =~ s/\&(?:#xB0|deg);/°/g;
    $s =~ s/\b([Ii])nt'l\b/\1nternational/g;
    my $debug__orig_state = $state;
    if ($state eq STATE__INITIAL || $state eq STATE__LIMINAL) {
      if ($s =~ /^\s*<h4>(.*?)<\/h4>/s) {
	log_debug "current channel is $1" if $debug > 1;
	$regs->{'current-channel'} = $1;
	$state = STATE__SCHEDULE;
	$node = {};
	$i += 1;
      } elsif ($s =~ /^\s*<a id="(havas-tab-\d)" data-mdb-toggle="tab"/s) {
	log_debug "current id is $1" if $debug > 1;
	$regs->{'current-id'} = $1;
      } elsif ($s =~ /^\s*<span class="havas-schedule-wd[^""]*">(\w+)<\/span>/s) {
	log_debug "current dow is $1" if $debug > 1;
	$regs->{'current-dow'} = $1;
      } elsif ($s =~ /^\s*<span class="havas-schedule-date[^""]*">(\w{3})\s+(\d+)<\/span>/s) {
	log_debug "got month=$1, day=$2" if $debug > 1;
	$regs->{'id'}->{$regs->{'current-id'}} = $2;
	$regs->{$2}->{'month'} = $1;
	$regs->{$2}->{'day'} = $2 + 0;
	$regs->{$2}->{'dow'} = $regs->{'current-dow'};
	delete $regs->{'current-id'};
	delete $regs->{'current-dow'};
      } elsif ($s =~ /^\s*<meta property="article:modified_time" content="(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})+(\d{2}):(\d{2})" \/>/s) {
	$regs->{$2}->{'base-year'} = $1;
      }
    } elsif ($state eq STATE__SCHEDULE) {
      if ($s =~ /^\s*<div .*?aria-labelledby="(havas-tab-\d+)"/s) {
	my $day = $regs->{$regs->{'id'}->{$1}};
	log_debug 'regs = ' . Dumper $regs if $debug > 1;
	$day = $day->{'day'};
	log_debug "got id=$1 => new current day is $day" if $debug > 1;
	$regs->{'current-day'} = $day;
	$state = STATE__DAY;
      }
    } elsif ($state eq STATE__DAY) {
      if ($s =~ /^\s*([12]?\d):(\d\d)\s*([AP]M)\b/s) {
	my($h, $m, $moity) = ($1 + 0, $2 + 0, $3);
	$h -= 12 if $h == 12;
	$h += 12 if $moity eq 'PM';
	my $time = sprintf('%02d:%02d', $h, $m);
	log_debug "time is $time" if $debug > 1;
	$regs->{'current-time'} = $time;
	push @{$regs->{'times'}}, $time;
      } elsif ($s =~ /^\s*<span class="language-tag[^""]*">\s*(\w{3})\s*<\/span>/s) {
	log_debug "lang is $1" if $debug > 1;
	$regs->{'current-lang'} = $1;
      } elsif ($s =~ /^\s*<h3/s) {
	$state = STATE__SHOW_NAME;
      } elsif ($s =~ /^\s*<div .*?aria-labelledby="(havas-tab-\d+)"/s) {
	push @readahead, $s;
	$state = STATE__SCHEDULE;
      }
    } elsif ($state eq STATE__SHOW_NAME) {
      if ($s =~ /^\s*((?!\s)(?!<)(?:(?!<\/h3>).)*(?<=\S))\s*<\/h3>$/s) {
	log_debug "show name is $1" if $debug > 1;
	$regs->{'current-name'} = $1;
	$state = STATE__DURATION;
      }
    } elsif ($state eq STATE__DURATION) {
      if ($s =~ /^\s*<p class="duration[^""]*">(\d+) minutes/s) {
	my $day = $regs->{'current-day'};
	my $duration = $1;
	log_debug "duration is $duration" if $debug > 1;
	$it->{$day}->{$regs->{'current-time'}}->{'name'} = $regs->{'current-name'};
	$it->{$day}->{$regs->{'current-time'}}->{'lang'} = $regs->{'current-lang'};
	$it->{$day}->{$regs->{'current-time'}}->{'duration'} = $duration;
	$it->{$day}->{'dow'} = $regs->{$day}->{'dow'};
	$it->{$day}->{'day'} = $regs->{$day}->{'day'};
	$it->{$day}->{'month'} = $regs->{$day}->{'month'};
	delete $regs->{'current-time'};
	delete $regs->{'current-name'};
	delete $regs->{'current-lang'};
	$state = STATE__DAY;
      }
    } else {
      die "$0: Internal error: Reached unknown state \"$state\"\n";
    }
    log_debug "switched state from $debug__orig_state to $state" if $debug > 1 && $debug__orig_state ne $state;
  last if $state eq STATE__FOOTER;
  }
  log_debug 'end of feed reached' if $debug;
  close INPUT;
  $it = {+$regs->{'current-channel'} => $it} if $it;
  log_debug 'GOT HERE '.Dumper $it if $debug > 2;#XXXZZZ
  return $it;
}

sub news_program_p ($) {
  my($name) = @_;
  return $name =~ /\bNews\b/;
}

sub match_program_language ($$) {
  my($node, $language) = @_;
  my $it = defined $language && $language =~ /\S/ && $node->{'lang'} =~ /^$language$/i;
  return $it;
}

sub find_language_program ($$) {
  my($data, $t) = @_;
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
  my $target_day = $mday;
  my $target_month = POSIX::strftime('%b', $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
  my $target_dow = uc POSIX::strftime('%a', $sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
  my @found;
  log_debug "target day $target_day, month $target_month, dow $target_dow" if $debug;
  for my $channel (keys %$data) {
    my $channel_data = $data->{$channel};
    if (ref $channel_data) {
      for my $day (keys %$channel_data) {
	my $day_data = $channel_data->{$day};
	if ($day == $target_day && ref $day_data) {
	  for my $time (keys %$day_data) {
	    my $time_data = $day_data->{$time};
	    if (ref $time_data && (!defined $lang || match_program_language($time_data, $lang))) {
	      push @found, [$time, $channel, ucfirst lc $day_data->{'dow'}, $day, $day_data->{'month'}, $time_data->{'name'}, $time_data->{'duration'}]
		  unless $time_data->{'name'} eq 'SIGN OFF';
	    }
	  }
	}
      }
    }
  }
  return [sort { $a->[0] cmp $b->[0] } @found];
}

sub ignore_program_p ($) {
  my($program) = @_;
  return grep { $_ eq $program } @{$config->{'/'}->{'ignore'}} if defined $config && defined $config->{'/'}->{'ignore'};
}

sub QUERY__NEXT () { 'NEXT' }
sub QUERY__MAIN () { 'MAIN' }

sub RESULT__MAIN_SEGMENT        () { 'main' }
sub RESULT__LAST_NEWS_BROADCAST () { 'news' }
sub RESULT__LAST_VALID_PROGRAM  () { 'last' }

sub FLAG__TODAYS_SCHEDULE       () { 1 }
sub FLAG__UPCOMING_PROGRAM      () { 2 }
sub FLAG__CURRENT_PROGRAM       () { 3 }

sub filter_listing ($$;$) {
  my($data, $t, $query_type) = @_;
  my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($t);
  my $target_time = 60*$hour + $min if $query_next_program_p;
  my $something_done_p;
  my $all_same_channel_p;
  my $last_end_time;
  my @data_to_display;
  my @consecutive;
  my $consecutive_has_news_p;
  my @last_news_program;
  my @last_valid_program;
  my $has_news_p;

  $query_type = $query_next_program_p? QUERY__NEXT: $query_main_program_p? QUERY__MAIN: undef if !defined $query_type;
  my $query_main_program_p = $query_type eq QUERY__MAIN;
  my $query_next_program_p = $query_main_program_p || $query_type eq QUERY__NEXT;

  for my $node (@$data) {
    my($time, $channel, $dow, $day, $month, $name, $duration) = @$node;
    my $broadcast_time = 60*$1 + $2 if $time =~ /^(\d\d):(\d\d)$/;
    my $end_time = $broadcast_time + $duration;
    my $flag;
    if (!defined $target_time) {
      $flag = FLAG__TODAYS_SCHEDULE;
    } elsif ($broadcast_time > $target_time) {
      $flag = FLAG__UPCOMING_PROGRAM;
    } elsif ($broadcast_time <= $target_time && $target_time <= $end_time) {
      $flag = FLAG__CURRENT_PROGRAM;
    }
    if (defined $flag) {
      push @data_to_display, [$flag, $broadcast_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration];
      if (!defined $all_same_channel_p) {
	$all_same_channel_p = $channel;
      } elsif ($all_same_channel_p && $all_same_channel_p ne $channel) {
	$all_same_channel_p = 0;
      }
      if (defined $last_end_time && $broadcast_time == $last_end_time) {
	push @consecutive, $data_to_display[$#data_to_display];
      } else {
	@consecutive = ($data_to_display[$#data_to_display]);
      }
      @last_news_program = ($data_to_display[$#data_to_display]) if news_program_p $name;
      $something_done_p = 1;
      $last_end_time = $end_time;
      $consecutive_has_news_p = 1 if news_program_p $name;
    } else {
      @last_valid_program = @data_to_display;
      @consecutive = ();
      $consecutive_has_news_p = 0;
    }
  last if $query_main_program_p? @consecutive == 2: $something_done_p && defined $target_time;
  }
  my $it = { 'all-same-channel-p' => $all_same_channel_p, 'results' => \@data_to_display };
  if ($query_main_program_p) {
    if (@consecutive > 1 && $consecutive_has_news_p) {
      $it->{'type'} = RESULT__MAIN_SEGMENT;
      $it->{'results'} = \@consecutive;
    } elsif (@last_news_program) {
      $it->{'type'} = RESULT__LAST_NEWS_BROADCAST;
      $it->{'results'} = \@last_news_program;
    } elsif (@last_valid_program) {
      $it->{'type'} = RESULT__LAST_VALID_PROGRAM;
      $it->{'results'} = \@last_valid_program;
    }
  }
  return $it;
}

sub display_listing ($$;$) {
  my($filtered_data, $t, $short_p) = @_;
  my $type = $filtered_data->{'type'};
  my $data = $filtered_data->{'results'};
  my $all_same_channel_p = $filtered_data->{'all-same-channel-p'};

  my %annotated;
  my $something_done_p = 0;
  for my $node (@$data) {
    my($flag, $start_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration) = @$node;
    my $lead;
    my $comment;
    if ($flag == FLAG__TODAYS_SCHEDULE) {
      if ($chinese_p) {
	my $tmp = format_time($end_time, $short_p);
	$tmp =~ s/午夜|凌晨|上午|中午|下午|晚上//;
	if (!$something_done_p) {
	  $lead .= format_date($month, $day, $dow);
	  $lead .= sprintf('，喺 %s ', format_channel $channel) if $all_same_channel_p;
	  $lead .= '嘅';
	  $lead .= format_language($lang) if defined $lang;
	  $lead .= sprintf("%s：\n", ($type eq RESULT__MAIN_SEGMENT? '主要新聞時段': $type eq RESULT__LAST_NEWS_BROADCAST? '新聞時段': '節目'));
	}
	$lead .= sprintf('%s%s%s', format_time($time, 1), ($speak_mode_p? '至': '～'), $tmp);
	$lead .= sprintf('喺 %s 播放', format_channel $channel) unless $all_same_channel_p;
	$lead .= '：'
      } else {
	if (!$something_done_p) {
	  $lead .= sprintf('%s for ', ($type eq RESULT__MAIN_SEGMENT? 'Main segment': $type eq RESULT__LAST_NEWS_BROADCAST? 'Last news broadcast': 'Schedule'));
	  $lead .= sprintf('%s programs on ', format_language($lang)) if defined $lang;
	  $lead .= format_date($month, $day, $dow);
	  $lead .= sprintf(' on %s', format_channel $channel) if $all_same_channel_p;
	  $lead .= ":\n";
	}
	$lead .= format_time($time, $short_p);
	$lead .= sprintf(' on %s', format_channel $channel) unless $all_same_channel_p;
	$lead .= $speak_mode_p? '. ': ': ';
	if (defined $duration && $duration) {
	  $comment = sprintf(' (%s)', format_duration $duration) unless defined $annotated{$name} && $annotated{$name} == $duration;
	  $annotated{$name} = $duration;
	}
      }
    } elsif ($flag == FLAG__UPCOMING_PROGRAM) {
      if ($chinese_p) {
	$lead .= '跟住係，' if $something_done_p;
	$lead .= sprintf('%s ', format_channel $channel) unless $all_same_channel_p;
	$lead .= '下一個節目係，' unless $something_done_p;
	$lead .= sprintf('%s播放，', format_time($time, $short_p));
	if (defined $duration && $duration) {
	  $lead .= sprintf('%s嘅，', format_duration($duration)) unless defined $annotated{$name} && $annotated{$name} == $duration;
	  $annotated{$name} = $duration;
	}
      } elsif ($something_done_p) {
	$lead .= 'followed by ';
      } else {
	$lead .= sprintf('Next at %s', format_time $time, $short_p);
	$lead .= sprintf(' on %s', format_channel $channel) unless $all_same_channel_p;
	$lead .= $speak_mode_p? '. ': ': ';
      }
    } elsif ($flag == FLAG__CURRENT_PROGRAM) {
      if ($chinese_p) {
	$lead .= sprintf('%s ', format_channel $channel) unless $all_same_channel_p;
	$lead .= '現正播放嘅節目係：';
	$comment = sprintf('，直至%s', format_time($end_time, $short_p));
      } else {
	$lead = 'Currently on';
	$lead .= sprintf(' %s', format_channel $channel) unless $all_same_channel_p;
	$lead .= sprintf(', until %s', format_time($end_time, $short_p));
	$lead .= ': ';
      }
    }
    $name = $chinese_program_name{$name} if $chinese_p && defined $chinese_program_name{$name};
    communicate $lead . $name . $comment;
    $something_done_p = 1;
  }
  return scalar @$data;
}

sub announce_current_date () {
  my($month, $day, $dow) = ($1 + 0, $2 + 0, $3 + 0) if strftime('%m %e %w', localtime adjusted_time) =~ /^(\d+)\s+(\d+)\s+(\d+)/s;
  communicate sprintf(($chinese_p? '今日係%s': 'Today is %s.'), format_date $month, $day, $dow);
}

sub announce_current_time () {
  # pico2wav needs the period, otherwise there will be no pause after "p.m."
  communicate sprintf(($chinese_p? '現在係%s': 'It is now %s.'), format_time POSIX::strftime('%H:%M', localtime adjusted_time));
}

sub enter_infinite_loop () {
  select((select(STDERR), $| = 1)[0]); # I don't know why this is needed for STDERR
  $query_next_program_p = 1;
  my $announcement_delta = 300;
  my $expiry_delta = 1;
  log_debug 'OMNI TV Cantonese News monitoring loop started' if $debug || $verbose;
  log_debug sprintf '[%s]', join(' ', (
	(defined $lang? "Lang=$lang": ()),
	(defined $prov? "Prov=$prov": ()),
	(defined $delta_t? "Δt=$delta_t": ()),
	#(defined $test_data_file? "TestDataFile=$test_data_file": ()),
	sprintf('%sBroadcast', $broadcast_mode_p? '+': '-'),
	sprintf('%sChinese', $chinese_p? '+': '-'),
	sprintf('%sDebug', $debug? '+': '-'),
	sprintf('%sDryRun', $dry_run_p? '+': '-'),
	sprintf('%sLoop', $loop_mode_p? '+': '-'),
	sprintf('%sOnce', $once_p? '+': '-'),
	sprintf('%sQuiet', $quiet_p? '+': '-'),
	sprintf('%sQueryMain', $query_main_program_p? '+': '-'),
	sprintf('%sSpeak', $speak_mode_p? '+': '-'),
	sprintf('%sVerbose', $verbose? '+': '-'),
      )) if $debug || $verbose;
  log_debug sprintf '[%s]', join(' ', (
	"lat=$lat",
	"lon=$lon",
      )) if $debug || $verbose;
  log_debug(sprintf '[ignore=%s]', join(',', map { "($_)" } @{$config->{'/'}->{'ignore'}})) if defined $config->{'/'}->{'ignore'};

  for (my($data, $main_program, $next_program, $start_time, $end_time, $name, $announced, $expiry, $main_program_p, $last_news_p);;) {
    my $recorded_start_time;
    $now = adjusted_time;
    my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime $now;
    my $delta_minutes = 60*$hour + $min;
    my $midnight_today = POSIX::mktime(0, 0, 0, $mday, $mon, $year);
    my($reporting_origin, $reporting_delta) = ($midnight_today, $now - $midnight_today);
    if (!defined $start_time || (defined $expiry && $now > $expiry)) {
      state $last_retry_time;
      my $previous_end_time = $end_time;
      $data = get_feed_data;
      my $full_listing = find_language_program $data, $reporting_origin if defined $data;
      if (!$full_listing || !@$full_listing) { # If we have zero results something is probably wrong. Force a retry but don't overload the server
	if (!defined $last_retry_time || $now - $last_retry_time >= 3600) {
	  $data = get_feed_data 'cached data failed sanity check';
	  $full_listing = find_language_program $data, $reporting_origin;
	  $last_retry_time = $now;
	}
      }
      $main_program = filter_listing $full_listing, $reporting_origin + $reporting_delta, QUERY__MAIN;
      $next_program = filter_listing $full_listing, $reporting_origin + $reporting_delta;
      (my $flag, $start_time, $end_time, my $time, my $channel, my $dow, my $day, my $month, $name, my $duration) = @{$next_program->{'results'}->[0]} if @{$next_program->{'results'}};
      $recorded_start_time = $start_time;
      if (!defined $start_time) {
	log_debug "filter returned zero results, trying tomorrow's date" if $debug;
	$reporting_origin += 86400;
	$reporting_delta = 0;
	$full_listing = find_language_program $data, $reporting_origin;
	$main_program = filter_listing $full_listing, $reporting_origin + $reporting_delta, QUERY__MAIN;
	$next_program = filter_listing $full_listing, $reporting_origin + $reporting_delta;
	($flag, $start_time, $end_time, $time, $channel, $dow, $day, $month, $name, $duration) = @{$next_program->{'results'}->[0]} if @{$next_program->{'results'}};
      }
      if (!defined $start_time) {
	log_debug "still zero results; something is wrong" if $debug || $verbose;
      } else {
	log_debug "recorded start time $start_time, end time $end_time" if $debug;
	# Figure out real start and end times
	# FIXME this will be wrong if DST changes
	$start_time = calculate_real_time($start_time, $reporting_origin);
	$end_time = calculate_real_time($end_time, $reporting_origin);
	log_debug sprintf "real start time %d '%s', end time %d '%s'", $start_time, POSIX::strftime('%F %T', localtime $start_time), $end_time, POSIX::strftime('%F %T', localtime $end_time) if $debug;
	# If we just finished a matching program then don't bother announcing this one
	if (defined $previous_end_time && $previous_end_time == $start_time) {
	  $expiry = $end_time - $expiry_delta; # avoid re-checking main-program-p before next announcement because we just announced
	  log_debug sprintf "previous end time = start time, expiry set to %d '%s'", $expiry, POSIX::strftime('%F %T', localtime $expiry) if $debug || $verbose;
	}
      }
    }
    if (defined $main_program && @{$main_program->{'results'}}) {
	my @m = @{$main_program->{'results'}};
	my $t = $main_program->{'type'};
	($_, my $main_start_time, $_, $_, $_, $_, $_, $_, my $name1, $_) = @{$m[0]};
	($_, $_, my $main_end_time, $_, $_, $_, $_, $_, my $name2, $_) = @{$m[$#m]};
	my $det = $delta_minutes + $announcement_delta/60; # we can't just use $delta_minutes because announcement is a few minutes before
	my $inside_p = $main_start_time <= $det && $det <= $main_end_time;
	$main_program_p = $inside_p && $t eq RESULT__MAIN_SEGMENT;
	$last_news_p = $inside_p && $t eq RESULT__LAST_NEWS_BROADCAST;
	$next_program = $main_program if $main_program_p;
    }
    my $dt = $start_time - $now;
    my $sleep_time;
    log_debug sprintf "delta to next program = %d (start time %d '%s')", $dt, $start_time, POSIX::strftime('%F %T', localtime $start_time) if $debug;
    if ($dt <= $announcement_delta && (!defined $announced || $announced < $start_time - $announcement_delta)) {
      my $night_p = POSIX::strftime('%H', localtime $now) =~ /^0[0-7]$/;
      my $program_name = $next_program->{'results'}->[0]->[8] if defined $next_program->{'results'}->[0]->[8]; # FIXME need to convert to proper OO
      if ($quiet_p && $night_p && $speak_mode_p) {
	log_debug "an announcement would have been made but it's night and we're in quiet mode" if $debug || $verbose;
      } elsif ($query_main_program_p && !$main_program_p) {
	log_debug "an announcement would have been made but it's not the main program and we're told to look for that" if $debug || $verbose;
      } elsif ($dt < 0 && $speak_mode_p) { # program already started - don't bother announcing
	;
      } elsif (ignore_program_p($program_name)) {
	log_debug sprintf "an announcement would have been made but \"%s\" is ignored", $program_name if $debug || $verbose;
      } else {
	start_talking;
	announce_current_time;
	display_listing $next_program, $now, 1;	# use short times because we just announced a full time
	if ($main_program_p) {
	  communicate($chinese_p? '呢個係今日嘅主要新聞時段': "This is today's main broadcast.");
	} elsif ($last_news_p) {
	  communicate($chinese_p? '呢個係今日最後一次新聞時段': "This is today's last news broadcast.");
	}
	stop_talking;
	turn_tv_on if $main_program_p || $last_news_p;
    last if $once_p;
      }
      $announced = $now;
      $expiry = $end_time - $announcement_delta - $expiry_delta; # must re-check main-program-p before announcement
      $sleep_time = $expiry - $now;
      log_debug sprintf "remembered announced time, expiry set to %d '%s', sleep time set to %d", $expiry, POSIX::strftime('%F %T', localtime $expiry), $sleep_time if $debug || $verbose;
    } else {
      $sleep_time = $dt/2;
      $sleep_time = 1 if $sleep_time < 1;
    }
    # clip sleep time to reasonable range
    if (!defined $sleep_time || $sleep_time < 1) {
      log_debug "INTERNAL ERROR: invalid sleep time \"$sleep_time\" clipped";
      $sleep_time = 1;
    } elsif ($sleep_time > $max_sleep) {
      $sleep_time = $max_sleep;
    }
    log_debug "sleep $sleep_time" if $debug;
    sleep $sleep_time;
  }
}

sub find_languages () {
  my %languages;
  for (my $i = 0; $i < 2; $i += 1) {
    local $omni_1_p = $i;
    my $data = get_feed_data;
    for my $j (keys %$data) {
      my $channel = $data->{$j};
      for my $k (keys %$channel) {
	my $day = $channel->{$k};
	for my $l (keys %$day) {
	  my $slot = $day->{$l};
	  if (ref $slot) {		# It could be something weird like "May"
	    my $lang = $slot->{'lang'};
	    if (defined $lang) {
	      $languages{$lang}->{'channels'}->{$j =~ s/ Channel$//r} = 1;
	      $languages{$lang}->{'dows'}->{$day->{'dow'}} = 1;
	    }
	  }
	}
      }
    }
  }
  return \%languages;
}

sub by_dow {
  $dow_numbers{$a} <=> $dow_numbers{$b}
}

sub format_dows (@) {
  my @dows = @_;
  my @it;
  for my $dow (@dows) {
    my $i = $dow_numbers{$dow};
    if (defined $i) {
      $it[$i] = $dow_codes{$dow}->[0];
    }
  }
  return join('', map { defined $it[$_]? $it[$_]: ' ' } 1..7);	# XXX
}

sub show_languages () {
  my $languages = find_languages;
  my $ui = $chinese_p? 'zh': 'en';
  my $fmt = "%-4s  %-15s  %-7s   %s\n";
  if (%$languages) {
    printf $fmt, 'Code', 'Language', 'Days', 'Channel(s)';
    printf $fmt, '====', '========', '====', '==========';
    print map { sprintf($fmt, $_,
			      (defined $langs{$_}? $langs{$_}->{$ui}: ''),
			      format_dows(keys %{$languages->{$_}->{'dows'}}),
			      join(', ', sort keys %{$languages->{$_}->{'channels'}}) ) } sort keys %$languages;

  } else {
    print "No languages found.\n";
  }
}

sub determine_correct_channel () {
  if (defined $lang) {
    my $languages = find_languages;
    if (%$languages) {
      my $det = $languages->{$lang};
      die "Language $lang not found in schedules for province \U$prov\n" unless defined $det;
      if (keys %$det == 1) {
	$omni_1_p = (keys %$det)[0] =~ /1/s;
	log_debug sprintf "Channel for language %s seems to be OMNI %d", $lang, ($omni_1_p? 1: 2) if $debug;
      } else {
	die "Language $lang is found in both channels. Please specify --channel before --lang.\n" if !defined $omni_1_p;
      }
    }
  }
}

$SIG{'TERM'} = sub {
  log_debug 'OMNI News monitoring shut down' if $debug || $verbose;
  exit(0);
};
$SIG{'INT'} = $SIG{'TERM'};
$SIG{'HUP'} = $SIG{'TERM'};
$SIG{'ALRM'} = sub { $debug = 1; log_debug 'Debugging turned on by ALRM signal'; };
$SIG{'STOP'} = sub { $debug = 0; log_debug 'Debugging turned off by STOP signal'; };
$SIG{'CONT'} = sub {};

sub usage (;$) {
  my($st) = @_; my $h = $st? *STDERR: *STDOUT;
  my $url = feed_url;
  print $h <<EOF;
Usage: $0 [OPTION]...
Figure out when OMNI News Cantonese is being aired by checking the scheduile.

  -A, --all                   Match all programs instead of a specific language
  -b, --broadcast             Generate audio files for speech-synthesized
                              announcements to work around network latency
      --channel=NUMBER        Use specified channel NUMBER (for --all or for
                              a --language that appears on both channels)
EOF
  print $h <<EOF if $debug;
      --dry-run               Do not execute any external commands
  -I, --data-file=FILE        Use test feed data in specified FILE
EOF
  print $h <<EOF;
      --language=CODE         Use the language identified by the specified CODE
                              (three-letter OMNI News code, not ISO code)
      --languages             Show a list of all languages in the schedule
      --loop                  Loop mode (continually announce next program)
END
  print $h <<EOF if $debug;
      --max-sleep=N           Clip max sleep() to N seconds (N must be > 1)
EOF
  print $h <<EOF;
  -n, --next                  Display next match instead of all matches
EOF
  print $h <<EOF if $debug;
      --once                  Exit loop after first annoucement
EOF
  print $h <<EOF;
      --province=CODE         Use the province identified by the specified CODE
  -q, --quiet                 Avoid speech synthesis between midnight and 8am
  -s, --speak                 Speak the result instead of displaying it
EOF
  print $h <<EOF if $debug;
      --test-ignore=NAME      Check if program with specified NAME is ignored
EOF
  print $h <<EOF;
  -T, --today                 Display today's schedule
EOF
  print $h <<EOF if $debug;
  -W, --what-if=TIMESTAMP     Pretend current time is TIMESTAMP (Unix epoch)
EOF
  print $h <<EOF;
  -v, --verbose               Explain what is being done
  -z, --chinese               Display results in traditional Chinese, or speak
                              results in Cantonese (MacOS only)
      --debug                 Produce lots of debugging output (can be specified
                              more than once for additional verbosity)
      --help                  Display this help and exit
EOF
  print $h <<EOF unless $debug;
                              (--debug --help to show debugging options)
EOF
  print $h <<EOF;

In loop mode, debugging can be turned on and off via the ALRM and STOP signals.
This can be done through svc -a and svc svc -p if running through daemontools.

If you need to check the schedule for any reason, it is at
$url
EOF
  exit $st;
}

$config = read_ini $config_file;
$config = read_ini $config_file_fallback if !defined $config;

Getopt::Long::config('bundling');
GetOptions(
  'A|all' => sub { $lang = undef },
  'b|broadcast' => \$broadcast_mode_p,
  'ch|chan|channel=i' => sub { my($key, $val) = @_; die "Channel must be 1 or 2\n" if $val != 1 && $val != 2; $omni_1_p = $val == 1? 1: 0 },
  'd|debug+' => \$debug,
  'dry-run' => \$dry_run_p,
  'prov|province=s' => sub { my($key, $val) = @_; $prov = lc $val; },
  'I|data-file=s' => \$test_data_file,
  'lang|language=s' => sub { my($key, $val) = @_; $lang = uc $val; },
  'languages' => \$show_languages_p,
  'loop' => \$loop_mode_p,
  'max-sleep=i' => sub { my($key, $val) = @_; die "Invalid max-sleep $val" unless $val > 0; $max_sleep = $val },
  'n|next' => \$query_next_program_p,
  'once' => \$once_p,
  'q|quiet' => \$quiet_p,
  's|speak' => \$speak_mode_p,
  'test-ignore=s' => sub { my($key, $val) = @_; printf(ignore_program_p $val? "\"%s\" is ignored\n": "\"%s\" is not ignored\n", $val); exit(0); },
  'T|today' => \$query_main_program_p,
  'W|what-if=i' => sub { my($key, $val) = @_; $delta_t = $val - time; },
  'v|verbose' => \$verbose,
  'z|zh|chinese' => \$chinese_p,
  'help' => \&usage,
) || usage(1);

die "$0: \"$prov\" does not look like a valid two-letter province code\n" unless $prov =~ /^[a-z]{2}$/;
$now = adjusted_time;

binmode STDIN, ':utf8';
binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

my $coords = guess_coordinates;
($lat, $lon) = ($coords->{'lat'}, $coords->{'lon'}) unless defined $lat;
die "$0: Can't determine coordinates\n" unless defined $coords;

die "--loop and --languages cannot be used together\n" if $loop_mode_p && $show_languages_p;

if ($loop_mode_p) {
  determine_correct_channel;
  enter_infinite_loop;
} elsif ($show_languages_p) {
  show_languages;
} else {
  my $something_done_p;
  determine_correct_channel;
  my $data = get_feed_data;
  log_debug('parsed data is ' . Dumper $data) if $debug;

  my $reporting_origin = $now;
  my $full_listing = find_language_program $data, $reporting_origin;
  my $listing = filter_listing $full_listing, $reporting_origin;

  if ($query_next_program_p && !@{$listing->{'results'}}) {
    my($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($now + 82800); # 23 hours, to avoid DST issues
    $reporting_origin = POSIX::mktime(0, 0, 0, $mday, $mon, $year);
    log_debug "no results were found, adjusting reporting origin to $reporting_origin" if $debug || $verbose;
    $full_listing = find_language_program $data, $reporting_origin;
    $listing = filter_listing $full_listing, $reporting_origin;
  }
  $something_done_p = display_listing $listing, $reporting_origin;
  print "No results were found for language $lang for today.\n" if !$something_done_p;
}
